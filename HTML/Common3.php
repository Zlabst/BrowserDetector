<?php
declare(ENCODING = 'utf-8');
namespace HTML;

/* vim: set expandtab tabstop=4 shiftwidth=4 set softtabstop=4: */

/**
 * \HTML\Common3: fork of HTML_Common2 package with additional features,
 * originally used in HTML_Page2, HTML_Javascript, HTML_Quickform or other
 * packages
 *
 * PHP versions 5 and 6
 *
 * LICENSE:
 *
 * Copyright (c) 2007 - 2009, Thomas Mueller <t_mueller_stolzenhain@yahoo.de>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * * The names of the authors may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @category  HTML
 * @package   \HTML\Common3
 * @author    Thomas Mueller <t_mueller_stolzenhain@yahoo.de>
 * @copyright Thomas Mueller <t_mueller_stolzenhain@yahoo.de>
 * @license   http://opensource.org/licenses/bsd-license.php New BSD License
 * @version   SVN: $Id$
 * @link      http://pear.php.net/package/\HTML\Common3
 */

/**
 * Exception classes for \HTML\Common3
 */
require_once 'HTML/Common3/Exception.php';

/**
 * class containing global variables for \HTML\Common3
 */
require_once 'HTML/Common3/Globals.php';

/**
 * class Interface for \HTML\Common3
 */
require_once 'HTML/Common3/Face.php';

/**#@+
 * Determines how content is added to the body.
 *
 * @var integer
 */
define('HTML_APPEND', true);
define('HTML_PREPEND', 0);
define('HTML_REPLACE', false);
/**#@-*/

// {{{ \HTML\Common3

/**
 * Base class for HTML classes
 *
 * \HTML\Common3: fork of HTML_Common2 package with additional features,
 * originally used in HTML_Page2, HTML_Javascript, HTML_Quickform or other
 * packages
 *
 * Optionally it is able to use HTML_Entities.
 * Optionally it is able to use I18Nv2_Negotiator to detect the charset and the
 * language
 *
 * @category  HTML
 * @package   \HTML\Common3
 * @author    Thomas Mueller <t_mueller_stolzenhain@yahoo.de>
 * @copyright Thomas Mueller <t_mueller_stolzenhain@yahoo.de>
 * @license   http://opensource.org/licenses/bsd-license.php New BSD License
 * @link      http://pear.php.net/package/\HTML\Common3
 * @abstract
 */
abstract class Common3
implements \HTML\Common3\Face
{
    // {{{ properties

    /**
     * HTML Tag (Name) of the Element
     *
     * @var      string
     * @see      getElementName()
     * @access   protected
     * @readonly
     */
    protected $_elementName = '';

    /**
     * associative array of attributes
     *
     * use the {@link initAttributes()} method to reset the attributes to the
     * default values
     *
     * @var      array
     * @see      setAttribute()
     * @see      getAttribute()
     * @see      initAttributes()
     * @access   protected
     */
    protected $_attributes = array();

    /**
     * List of attributes to which will be announced via
     * {@link onAttributeChange()} method rather than performed by
     * \HTML\Common3 class itself
     *
     * contains all required attributes
     *
     * @var      array
     * @see      onAttributeChange()
     * @see      getWatchedAttributes()
     * @access   protected
     * @readonly
     */
    protected $_watchedAttributes = array();

    /**
     * Global options for all elements (generated by subclasses of \HTML\Common3)
     * use the {@link initOptions()} method to set or reset the options
     *
     * Preset options are
     * - 'charset':   string  charset parameter used in htmlspecialchars() or
     *                        htmlentities() calls, defaults to 'iso-8859-1'
     * - 'indent':    string  used to indent HTML elements, defaults to "    "
     * - 'linebreak': string  used to indicate linebreak, defaults to "\12"
     * - 'level':     integer used to indicate IndentLevel, defaults to "0"
     * - 'comment':   string  used for Element Comment
     * - 'browser':   array   that stores data about the browser
     * - 'i18n':      object  (I18N2_Negogitator) used for autodetecting charset
     *                        and language from the browser
     * - 'cache':     mixed   actually only bollean values stored
     * - 'mime':      string  MIME type of the document, defaults to "text/html"
     *
     * @var      array
     * @see      setLineEnd()
     * @see      getLineEnd()
     * @see      setCharset()
     * @see      getCharset()
     * @see      setTab()
     * @see      getTab()
     * @see      setOption()
     * @see      getOption()
     * @see      initOptions()
     * @access   protected
     */
    protected $_options = array();

    /**
     * Indicator to tell, if the Object is an empty HTML Element
     *
     * @var      boolean
     * @access   protected
     * @readonly
     */
    protected $_elementEmpty = false;

    /**
     * Indicator to tell, if the Object is an the Root of the HTML-Tree
     *
     * at default only the <html> element is a root element, but all other
     * elements can act as root, if they don't have a parent element
     * for example, if you want to create an Ajax response
     *
     * @var      boolean
     * @access   protected
     * @readonly
     */
    protected $_isRootElement = false;

    /**
     * array of Child Elements for an Element
     *
     * @var      array
     * @see      addElement()
     * @see      initElements()
     * @access   protected
     */
    protected $_elements = array();

    /**
     * Indicator to tell, if the Element is disabled from output
     *
     * @var      boolean
     * @see      setIfEnabled()
     * @see      isEnabled()
     * @see      enable()
     * @see      disable()
     * @access   protected
     */
    protected $_disabled = false;

    /**
     * Pointer to the parent object
     *
     * @var      object
     * @access   protected
     */
    protected $_parent = null;

    /**
     * Pointer to the HTML object
     *
     * @var      object
     * @access   protected
     */
    protected $_html = null;

    /**
     * Contains the !DOCTYPE definition
     *
     * @var      array
     * @see      setDoctype()
     * @see      getDoctype()
     * @access   protected
     */
    protected $_doctype = array(
        'type' => 'xhtml',
        'version' => '1.0',
        'variant' => 'strict'
    );

    /**
     * Array of HTML Elements which are possible as child elements
     *
     * @var      array
     * @access   protected
     * @readonly
     */
    protected $_posElements = array();

    /**
     * Array of HTML Elements which are forbidden as parent elements
     * (and its parents)
     *
     * @var      array
     * @access   protected
     * @readonly
     */
    protected $_forbidElements = array();

    /**
     * Array of Attibutes which are possible for an Element
     *
     * @var      array
     * @access   protected
     * @readonly
     */
    protected $_posAttributes = array();

    /**
     * Array of ID's
     *
     * @var      array
     * @access   protected
     * @see      HTML_QuickForm2_Node::$ids
     * @readonly
     */
    protected $_ids = array();

    /**
     * Namespace for the element
     *
     * @var     string
     * @see     setElementNamespace()
     * @see     getElementNamespace()
     * @access  protected
     */
    protected $_elementNamespace = '';

    /**
     * Namespace for the document
     *
     * @var     array
     * @see     setNamespace()
     * @see     getNamespace()
     * @access  protected
     */
    protected $_namespace = array(
        '' => '', //default Namespace for HTML-Documents
        'xml' => ''  //default XML Namespace
    );

    /**
     * Indicator to tell, if missing elements and attributes should be added
     * to the DTD
     *
     * @var     boolean
     * @access  protected
     */
    protected $_addToDtd = false;

    /**
     * Indicator to tell, if styles should be added to the <head> only
     *
     * not implemented yet
     *
     * @var     boolean
     * @access  protected
     */
    protected $_stylesToHeadOnly = false;

    /**
     * SVN Version for this class
     *
     * @var     string
     * @access  protected
     */
    const VERSION = '$Id$';

    // }}} properties
    // {{{ Constructor and Destructor ******************************************
    // {{{ __construct

    /**
     * Class constructor, sets default attributes
     *
     * @param string|array $attributes Array of attribute 'name' => 'value'
     *                                 pairs or HTML attribute string
     * @param \HTML\Common3 $parent     pointer to the parent object
     * @param \HTML\Common3 $html       pointer to the HTML root object
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common::HTML_Common()
     * @see    HTML_Common2::__construct()
     * @see    HTML_Page2::HTML_Page2()
     */
    public function __construct($attributes = null,
    \HTML\Common3 $parent = null, \HTML\Common3 $html = null)
    {
        //set parent and root element
        $this->_parent =& $parent;
        $this->_html   =& $html;
        $isRoot        = $this->isRoot();

        //set the default attributes and options
        $this->init($isRoot);

        $negotiator = null;

        if ($isRoot) {
            @require_once 'I18Nv2/Negotiator.php';

            if (class_exists('I18Nv2_Negotiator')) {
                //set default charset
                $negotiator = new \I18Nv2_Negotiator('en', 'iso-8859-1');

                $this->_options['i18n'] = $negotiator;

                $match = $negotiator->getCharsetMatch(array('iso-8859-1',
                'utf-8'));

                $this->_options['charset'] = $match;
            }
        }

        if (version_compare(PHP_VERSION, '5.9.9', '>')) {
            if (!is_unicode($attributes) && !is_string($attributes) &&
            !is_array($attributes)) {
                $attributes = '';
            }
        } else {
            if (!is_string($attributes) && !is_array($attributes)) {
                $attributes = '';
            }
        }

        if ($attributes) {
            //parse all given attributes
            $attributes = $this->parseAttributes($attributes);

            //set the document type directly to the element
            //only if this is the root element
            if (isset($attributes['doctype'])) {
                if ($isRoot) {
                    $doctype = $this->clean($attributes['doctype']);

                    if ($doctype) {
                        $this->setDoctype($doctype);
                    } else {
                        $this->setDoctype();//set default
                    }
                }

                unset($attributes['doctype']);
            }

            //set the line end directly to the root element
            if (isset($attributes['lineend'])) {
                if ($isRoot) {
                    $lineEnd = $this->clean($attributes['lineend']);

                    if ($lineEnd) {
                        $this->setLineEnd($lineEnd);
                    } else {
                        $this->setLineEnd(); //set default
                    }
                }

                unset($attributes['lineend']);
            }

            //set the charset
            if (isset($attributes['charset'])) {
                $charset = $this->clean($attributes['charset']);

                if ($charset) {
                    $this->setCharset($charset);
                } else {
                    $this->setCharset(); //set default
                }

                unset($attributes['charset']);
            } elseif ($parent !== null && is_object($parent)) {
                $this->setCharset($parent->getCharset());
            }

            //set the language
            if (isset($attributes['language'])) {
                $lang = $this->clean($attributes['language']);

                if ($lang) {
                    $this->setLang($lang);
                } else {
                    $this->setLang('std');
                }

                unset($attributes['language']);
            } elseif (isset($attributes['lang'])) {
                $lang = $this->clean($attributes['lang']);

                if ($lang) {
                    $this->setLang($lang);
                } else {
                    $this->setLang('std');
                }

                unset($attributes['lang']);
            } elseif (isset($attributes['xml:lang'])) {
                $lang = $this->clean($attributes['xml:lang']);

                if ($lang) {
                    $this->setLang($lang);
                } else {
                    $this->setLang('std');
                }

                unset($attributes['xml:lang']);
            } elseif (is_object($this->_parent)) {
                $lang = $this->_parent->getLang();

                if ($lang) {
                    $this->setLang($lang);
                } else {
                    $this->setLang('std');
                }
            } elseif ($isRoot) {
                if ($negotiator !== null) {
                    $lang = $negotiator->getLanguageMatch(array('en', 'de'));
                    $this->setLang($lang);
                } else {
                    $this->setLang('std');
                }
            } else {
                $this->setLang('std');
            }

            //set the mime type directly to the root element
            if (isset($attributes['mime'])) {
                if ($isRoot) {
                    $mime = $this->clean($attributes['mime']);

                    if ($mime) {
                        $this->setMime($mime);
                    } else {
                        $this->setMime(); //set default
                    }
                }

                unset($attributes['mime']);
            }

            //set the namespace
            if (isset($attributes['namespace'])) {
                $namespace = $this->clean($attributes['namespace']);

                if ($namespace) {
                    $this->setNamespace($namespace);
                } else {
                    $this->setNamespace();
                }

                unset($attributes['namespace']);
            }

            //set the document tabulator directly to the root element
            if (isset($attributes['tab'])) {
                if ($isRoot) {
                    $tab = $this->clean($attributes['tab']);

                    if ($tab) {
                        $this->setTab($tab);
                    } else {
                        $this->setTab(); //set default
                    }
                }

                unset($attributes['tab']);
            }

            //set the cache mode - not used at the moment
            if (isset($attributes['cache'])) {
                if ($isRoot) {
                    $cache = $this->clean($attributes['cache']);

                    if ($cache) {
                        $this->setCache($cache);
                    } else {
                        $this->setCache(false);
                    }
                }

                unset($attributes['cache']);
            }

            //merge the other attributes
            $this->mergeAttributes($attributes, false);
        }

        unset($negotiator);

        $root         = $this->getRoot();
        $docType      = $root->getDoctype(false);
        //$allElements  = \HTML\Common3\Globals::getAllElements();
        $allNamespace = \HTML\Common3\Globals::getAllNamespaces();

        $dt          = $docType['type'];    //doctype
        $ve          = $docType['version']; //version
        $va          = $docType['variant']; //variant
        $elementName = $this->getElementName();

        /*
        if (isset($allElements[$elementName][$dt][$ve]['empty'])) {
            if ($allElements[$elementName][$dt][$ve]['empty'] === true) {
                $this->_elementEmpty = true;
            } else {
                $this->_elementEmpty = false;
            }
        }
        */

        if (($empty = \HTML\Common3\Globals::isElementEmpty($elementName,
            $dt, $ve)) !== null) {
            $this->_elementEmpty = $empty;
        }

        if (isset($allNamespace[$dt][$ve]) &&
            !$this->getNamespace(false, '')) {
            $this->setNamespace($allNamespace[$dt][$ve], '');
        }

        //get all required attributes
        $watched = $this->_watchedAttributes;
        foreach ($watched as $attrib) {
            if (!isset($this->_attributes[$attrib]) ||
                $this->_attributes[$attrib] === null) {

                //required Attribute not set
                $this->setAttribute($attrib, '');

            }
        }

        //set Browser Object for the Root Element
        if ($isRoot && ini_get('browscap') &&
            isset($_SERVER['HTTP_USER_AGENT'])) {

            $browscapFile = ini_get('browscap');

            if (file_exists($browscapFile)) {
                $this->_options['browser'] = get_browser(null, false);

                //@todo: change settings ans possible child elements
                //depending on browser properties
            }
        }
    }

    // }}} __construct
    // }}} Constructor and Destructor ******************************************
    // {{{ Initialisation ******************************************************
    // {{{ initOptions

    /**
     * set/reset the options to default values
     *
     * @access protected
     * @return \HTML\Common3
     */
    protected function initOptions()
    {
        //set the default options
        $this->_options = array(
            'charset' => 'iso-8859-1',
            'indent' => "    ",
            'linebreak' => PHP_EOL,
            'level' => 0,           //Identlevel
            'comment' => '',      //Comment
            'browser' => null,      //Browser properties
            'i18n' => null,         //I18Nv2_Negotiator Object
            'cache' => false,       //Caching
            'mime' => 'text/html',  //MIME type
        );

        return $this;
    }

    // }}} initOptions
    // {{{ initAttributes

    /**
     * set the default attributes
     *
     * @access protected
     * @return \HTML\Common3
     */
    protected function initAttributes()
    {
        //set the default attributes
        $this->_attributes = array();

        return $this;
    }

    // }}} initAttributes
    // {{{ initElements

    /**
     * set the default elements
     *
     * @access protected
     * @return \HTML\Common3
     */
    protected function initElements()
    {
        //unset all existing child elements
        if (count($this->_elements)) {
            $keys = array_keys($this->_elements);
            foreach ($keys as $key) {
                unset($this->_elements[$key]);
            }
        }

        //set the default attributes
        $this->_elements = array();

        return $this;
    }

    // }}} initElements
    // {{{ init

    /**
     * set the default attributes and options
     *
     * @param boolean $isRoot TRUE, if the element is the Root element
     *
     * @access protected
     * @return \HTML\Common3
     */
    protected function init()
    {
        //set the default attributes
        $this->initAttributes();
        $this->initOptions();
        $this->initElements();

        return $this;
    }

    // }}} init
    // }}} Initialisation ******************************************************
    // {{{ API version *********************************************************
    // {{{ apiVersion

    /**
     * Returns the current API version
     *
     * @access public
     * @return string
     * @static
     * @see    HTML_Common::apiVersion()
     *
     * @assert() === '3.0.0'
     */
    public static function apiVersion()
    {
        return '3.0.0';
    }

    // }}} apiVersion
    // {{{ getApiVersion

    /**
     * Returns    the current API version
     *
     * @access public
     * @return string
     * @see    HTML_Common::apiVersion()
     *
     * @assert() === '3.0.0'
     */
    public function getApiVersion()
    {
        return self::apiVersion();
    }

    // }}} getApiVersion
    // {{{ getVersion

    /**
     * Returns    the current version
     *
     * @access public
     * @return string
     * @see    HTML_Common::apiVersion()
     */
    public function getVersion()
    {
        $class   = get_class($this);
        eval('$version = ' . __Namespace__ . "\\$class::VERSION;");
        $version = explode(' ', $version);

        return self::apiVersion() . '.' . $this->getStability() . $version[2];
    }

    // }}} getVersion
    // {{{ getStability

    /**
     * Returns    the current version
     *
     * @access public
     * @return string
     *
     * @assert() === 'Alpha'
     */
    public function getStability()
    {
        return 'Alpha';
    }

    // }}} getStability
    // }}} API version *********************************************************
    // {{{ getter and setter functions *****************************************
    // {{{ getElementName

    /**
     * Returns the name (HTML Tag) of the element
     *
     * @return string
     * @access public
     *
     * @assert() === ''
     */
    public function getElementName()
    {
        return strtolower($this->_elementName);
    }

    // }}} getElementName
    // {{{ setAttribute

    /**
     * Sets the value of the attribute
     * use {@link removeAttribute()} to delete an attribute
     *
     * @param string $name  Attribute name
     * @param string $value Attribute value (will be set to $name if omitted)
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common::setAttribute()
     * @see    HTML_Common2::setAttribute()
     * @see    __set()
     */
    public function setAttribute($name, $value = null)
    {
        //check first, if the attribute name is valid and not empty
        $name = (string) $name;

        if ($name == '') {
            return $this;
        }

        //clean the attribute name
        $name = strtolower($this->clean($name));

        if ($name == '') {
            return $this;
        }

        $elementName   = $this->getElementName();
        $root          = $this->getRoot();
        $docType       = $root->getDoctype(false);

        $typeName = \HTML\Common3\Globals::getTypeName($elementName, $name);

        if ($typeName === null) {
            //the attribute is not defined inside the global attributes
            return $this;
        }

        //if the value is an Style object
        //-> transform it to text
        if ($name == 'style') {
            if (is_object($value)) {
                if (method_exists($value, "toInline")) {
                    $value = (string) $value->toInline($elementName);
                } else {
                    //object couldn't converted into string
                    $value = null;
                }
            } else {
                //no object
                $value = $this->clean((string) $value);
            }
        } else {
            //no style
            $value = $this->clean((string) $value);
        }

        $attribType    = \HTML\Common3\Globals::getAttributeType($elementName,
        $name);
        $attribReplace = \HTML\Common3\Globals::getAttributeReplacement(
        $elementName, $name);

        $posAttributes = $this->getPosAttributes();

        //check, if the attribute is allowed
        if (!in_array($name, $posAttributes) && $attribReplace !== null) {
            if (is_string($attribReplace)) {
                //the attribute is not allowed, replace it
                $attribReplace = explode('##', $attribReplace);
                $name          = $attribReplace[0];

                if (isset($attribReplace[1])) {
                    //the old attribute is replaced by a value of the
                    //style attribute
                    //$value .= $attribReplace[1];
                }
            }
        }

        if (!in_array($name, $posAttributes) &&
            is_object($root) && $root->getAddingToDtd() &&
            (get_class($root) === '\HTML\Common3\Root\Html' ||
            is_subclass_of($root, '\HTML\Common3\Root\Html'))) {

            $dt = $docType['type'];    //doctype
            $ve = $docType['version']; //version
            $va = $docType['variant']; //variant

            //add new Attribute to Arrays
            $this->_posAttributes[$dt][$ve][$va][]   = $name;
            //\HTML\Common3\Globals::getAllAttributes()[$name]['replace']  = null;
            //\HTML\Common3\Globals::getAllAttributes()[$typeName]['type'] = '#CNAME';
            $attribType                             = '#CNAME';

            //add attribute to DTD
            $this->addDtdAttribute($elementName, $name);

            //reload possible Attributes
            $posAttributes = $this->getPosAttributes();
        }

        if (in_array($name, $posAttributes)) {
            //var_dump($value);
            //var_dump($attribType);
            if ($attribType == '#EMPTY') {
                $value = $name;
            } else {
                if (!\HTML\Common3\Globals::getAttributeHasSpaces($elementName,
                $name)) {
                    //no spaces are allowed in attribute value
                    $value = $this->clean($value);
                }
            }
            //var_dump($value);
            $idFound = true;
            $cid     = $root->_ids;

            if ($value) {
                if ($attribType === '#CNAME') {
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                    /*
                    if ($value && isset($allAttributes[$name]['_']) &&
                        !$allAttributes[$name]['_']) {
                        $value = str_replace('_', '-', $value);
                    }
                    */
                    if (!\HTML\Common3\Globals::isUnderScoreAllowed($elementName, $name)) {
                        $value = str_replace('_', '-', $value);
                    }
                } elseif ($attribType === '#URL') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                    //@todo URL Validation
                } elseif ($attribType === '#MIME') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                    //@todo MIME Validation
                } elseif ($attribType === '#COLOR') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                } elseif ($attribType === '#SCRIPT') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                } elseif ($attribType === '#STYLE') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                } elseif ($attribType === '#TIME') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                } elseif ($attribType === '#FONT') {
                    //just copied from #CNAME
                    if (\HTML\Common3\Globals::isAttributeLowerCased($elementName, $name)) {
                        $value = strtolower($value);
                    }
                } elseif ($attribType === '#ID') {
                    $value = strtolower($value);

                    if (isset($cid[$value]) && is_object($cid[$value])) {
                        $value = $root->generateId($this->getName());
                    }

                    $stored = $root->storeId($value);
                    if (!$stored) {
                        $value = null;
                    }
                } elseif ($attribType === '#IDREF') {
                    $value = strtolower($value);
                    $value = str_replace('#', '', $value);

                    if ((count($cid) == 0) ||
                        (!array_key_exists($value, $cid))) {
                        $registered = $root->registerId($value);
                        if (!$registered) {
                            $value = '';
                        }
                    }
                } elseif ($attribType === '#IDREFRAUTE') {
                    $value = strtolower($value);
                    $value = str_replace('#', '', $value);

                    if ((count($cid) == 0) ||
                        (!array_key_exists($value, $cid))) {
                        $registered = $root->registerId($value);
                        if (!$registered) {
                            $value = '';
                        }
                    }

                    if ($docType['type'] == 'html' &&
                        $docType['version'] == '5.0') {
                        $value = '#' . $value;
                    }
                } elseif (is_array($attribType)) {
                    if (!in_array($value, $attribType) &&
                        !in_array('#CNAME', $attribType)) {
                        $value = $attribType[0];
                    }
                    if ($value && isset($allAttributes[$name]['_']) &&
                        !$allAttributes[$name]['_']) {
                        $value = str_replace('_', '-', $value);
                    }
                } elseif (substr($attribType, 0, 2) === '##') {
                    $pregCode = '/' . substr($attribType, 2) . '/i';
                    $value    = preg_replace($pregCode, '', $value);
                } elseif ($attribType === '#NUMBER') {
                    $percent = (boolean) strpos($value, '%');
                    $value   = (int) $value;

                    if (!$value && isset($allAttributes[$name]['zero']) &&
                        !$allAttributes[$name]['zero']) {
                        $value = 1;
                    }

                    if ($percent) {
                        $value .= '%';
                    }
                } elseif ($attribType === '#I18NLANG') {
                    $value = strtolower($value);

                    //check, if the value has the right length as language code
                    if (strlen($value) > 3 || strlen($value) < 2) {
                        $value = 'std';
                    }

                    if ($value == 'std') {
                        if (is_object($this->_parent)) {
                            $value = $this->_parent->getAttribute($name);
                        } else {
                            $value = $root->getAttribute($name);
                        }
                    } else {
                        @require_once 'I18Nv2/Negotiator.php';

                        if (class_exists('I18Nv2_Negotiator')) {
                            $negotiator = new \I18Nv2_Negotiator('en',
                            'utf-8');
                            $sLang      = $negotiator->singleI18NLanguage();
                            $langCodes  = array_keys($sLang->getAllCodes());

                            if (!in_array($value, $langCodes)) {
                                //set to default
                                $value = 'std';
                            }
                        } else {
                            $value = 'std';
                        }
                    }
                } elseif ($attribType === '#I18NENCODING') {
                    $value = strtolower($value);

                    @require_once 'I18Nv2/Encoding.php';

                    if (isset($GLOBALS['_I18Nv2_Encoding_Names'])) {
                        $enc = $GLOBALS['_I18Nv2_Encoding_Names'];

                        $encodings  = array_keys($enc);
                        $valueUpper = strtoupper($value);

                        if (!in_array($valueUpper, $encodings)) {
                            //set to default
                            $value = 'iso-8859-1';
                        }
                    }
                }

                if ($value !== null) {
                    if (in_array($name, $this->_watchedAttributes)) {
                        //validate value before change
                        $this->onAttributeChange($name, $value);
                    } else {
                        //set new value
                        $this->_attributes[$name] = (string) $value;
                    }
                }
            }
        }

        return $this;
    }

    // }}} setAttribute
    // {{{ getAttribute

    /**
     * Returns the value of an attribute
     *
     * @param string $name Attribute name
     *
     * @return string|null Attribute value, null if attribute does not exist
     * @access public
     * @see    HTML_Common::getAttribute()
     * @see    HTML_Common2::getAttribute()
     *
     * @assert('foobar') === null
     * @assert('id')     === null
     */
    public function getAttribute($name)
    {
        $name = strtolower($this->clean((string) $name));

        if ($name != '' && isset($this->_attributes[$name])) {
            return (string) $this->_attributes[$name];
        } else {
            return null;
        }
    }

    // }}} getAttribute
    // {{{ getWatchedAttributes

    /**
     * Returns the watched attributes of the element
     *
     * @return array
     * @access public
     *
     * @assert() === array()
     */
    public function getWatchedAttributes()
    {
        return $this->_watchedAttributes;
    }

    // }}} getWatchedAttributes
    // {{{ setOption

    /**
     * Sets a (existing) global option to a new value
     * the option must be set with {@link initOptions} or with the constructor
     * {@link __construct}
     *
     * @param string $name  Option name
     * @param mixed  $value Option value
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common2::setOption()
     */
    public function setOption($name, $value)
    {
        $name = strtolower($this->clean($name));

        if ($name == ''/* || !isset($this->_options[$name])/**/) {
            //no name or unknown option
            //-> nothing to do
            return $this;
        }

        $linebreaks = array(
            'win' => "\15\12",
            'unix' => "\12",
            'mac' => "\15"
        );

        if (is_bool($value) || $value === "\t" || $value === "\n") {
            $valueX = '1'; //dummy value
        } else {
            $valueX = $this->clean($value);
        }

        if ($valueX != '') {
            if ('linebreak' === $name && isset($linebreaks[$valueX])) {
                $value = $linebreaks[$valueX];
            }

            $this->_options[$name] = $value;
        }

        return $this;
    }

    // }}} setOption
    // {{{ getOption

    /**
     * Gets a global option
     *
     * @param string $name Option name
     *
     * @return mixed|null Option value, null if option does not exist
     * @access public
     * @see    HTML_Common2::getOption()
     *
     * @assert('foobar')    === null
     * @assert('charset')   === 'iso-8859-1'
     * @assert('indent')    === '    '
     * @assert('linebreak') === "\12"
     * @assert('level')     === 0
     * @assert('comment')   === null
     * @assert('browser')   === null
     * @assert('i18n')      === null
     * @assert('mime')      === 'text/html'
     * @assert('cache')     === false
     */
    public function getOption($name)
    {
        $name = strtolower($this->clean($name));

        if ($name != '' && isset($this->_options[$name])) {
            $option = $this->_options[$name];
        } else {
            $option = null;
        }
        return $option;
    }

    // }}} getOption
    // {{{ getElementEmpty

    /**
     * Returns true, if the Element is empty, false otherwise
     *
     * @return boolean
     * @access public
     * @see    getEmpty
     *
     * @assert() === false
     */
    public function getElementEmpty()
    {
        if ($this->_elementEmpty) {
            return true;
        } else {
            return false;
        }
    }

    // }}} getElementEmpty
    // {{{ getIsRootElement

    /**
     * returns TRUE, if the element is the root element, returns false otherwise
     *
     * @return boolean
     * @access public
     *
     * @assert() === false
     */
    public function getIsRootElement()
    {
        if ($this->_isRootElement) {
            return true;
        } else {
            return false;
        }
    }

    // }}} getIsRootElement
    // {{{ getElements

    /**
     * returns the child element array
     *
     * @return array
     * @access public
     *
     * @assert() === array()
     */
    public function getElements()
    {
        return $this->_elements;
    }

    // }}} getElements
    // {{{ setDisabled

    /**
     * sets the disable flag for the element
     *
     * @param boolean $disabled TRUE, if the Element should be disabled
     *
     * @return \HTML\Common3
     * @access public
     */
    public function setDisabled($disabled = false)
    {
        if ($disabled) {
            $this->_disabled = true;
        } else {
            $this->_disabled = false;
        }

        return $this;
    }

    // }}} setDisabled
    // {{{ getDisabled

    /**
     * Returns true, if the Element is disabled
     *
     * @return boolean
     * @access public
     *
     * @assert() === false
     */
    public function getDisabled()
    {
        if ($this->_disabled) {
            return true;
        } else {
            return false;
        }
    }

    // }}} getDisabled
    // {{{ setParent

    /**
     * sets the parent object in the HTML tree
     *
     * @param \HTML\Common3 $parent the parent object
     *
     * @return \HTML\Common3
     * @access protected
     */
    protected function setParent(\HTML\Common3 $parent)
    {
        $this->_parent =& $parent;

        return $this;
    }

    // }}} setParent
    // {{{ getParent

    /**
     * Returns the parent object in the HTML tree
     *
     * @return \HTML\Common3
     * @access public
     *
     * @assert() === null
     */
    public function getParent()
    {
        return $this->_parent;
    }

    // }}} getParent
    // {{{ setHtml

    /**
     * sets the root object in the HTML tree
     *
     * @param \HTML\Common3 $html the root object
     *
     * @return \HTML\Common3
     * @access protected
     */
    protected function setHtml(\HTML\Common3 $html)
    {
        $this->_html =& $html;

        return $this;
    }

    // }}} setHtml
    // {{{ getHtml

    /**
     * Returns the root object in the HTML tree
     *
     * @return \HTML\Common3
     * @access public
     *
     * @assert() === null
     */
    public function getHtml()
    {
        return $this->_html;
    }

    // }}} getHtml
    // {{{ setCache

    /**
     * Defines if the document should be cached by the browser
     *
     * <p>Defaults to false.</p>
     *
     * <p>A fully configurable cache header is in the works. for now, though
     * if you would like to determine exactly what caching headers are sent to
     * to the browser, set cache to true, and then output your own headers
     * before calling {@link display}.</p>
     *
     * @param string|boolean|object $cache Options are currently 'true' or
     *                                     'false'
     *
     * @return \HTML\Common3
     * @access public
     * @see HTML_Page2::setCache()
     */
    public function setCache($cache = false)
    {
        if ($this->isRoot()) {
            if (!is_bool($cache) && !is_object($cache)) {
                $cache = strtolower($this->clean($cache));
            }

            if ($cache == 'true' || $cache === true) {
                $this->setOption('cache', 'public');
            } elseif ($cache == 'false' || $cache === false) {
                $this->setOption('cache', false);
            } elseif (is_string($cache)) {
                $this->setOption('cache', $cache);
            } elseif (is_object($cache)) {
                //@todo: implementation of PEAR::Cache and PEAR::Cache_Lite and
                //      ZEND_CACHE
            }
        } else {
            $root = $this->getRoot();
            $root->setCache($cache);
        }

        return $this;
    }

    // }}} setCache
    // {{{ getCache

    /**
     * Returns the root object in the HTML tree
     *
     * @return boolean
     * @access public
     *
     * @assert() === false
     */
    public function getCache()
    {
        if ($this->isRoot()) {
            return $this->getOption('cache');
        } else {
            $root = $this->getRoot();
            return $root->getCache();
        }
    }

    // }}} getCache
    // {{{ setDoctype

    /**
     * Sets or alters the !DOCTYPE declaration.
     *
     * <p>Can be set to "strict", "transitional" or "frameset".
     * Defaults to "XHTML 1.0 Transitional".</p>
     *
     * @param array|string $type (Optional) String containing a document type
     *
     * @access public
     * @return \HTML\Common3
     * @throws \HTML\Common3\DoctypeNotSupportedException
     * @see    HTML_Page2::setDoctype()
     */
    public function setDoctype($type = 'XHTML 1.0 Strict')
    {
        if ($this->isRoot()) {

            if (version_compare(PHP_VERSION, '5.9.9', '>')) {
                if (!is_unicode($type) && !is_string($type) && !is_array($type)) {
                    throw new \HTML\Common3\DoctypeNotSupportedException(
                        'Doctype has unsupported variable type!'
                    );
                }
            } else {
                if (!is_string($type) && !is_array($type)) {
                    throw new \HTML\Common3\DoctypeNotSupportedException(
                        'Doctype has unsupported variable type!'
                    );
                }
            }

            if (is_string($type)) {
                $this->_doctype = $this->parseDoctypeString((string) $type);
            } elseif (is_array($type)) {
                if (isset($type['type']) && isset($type['variant'])) {
                    $this->_doctype = $type;
                } else {
                    $type           = implode(' ', $type);
                    $this->_doctype = $this->parseDoctypeString($type);
                }
            }

            if (!isset($this->_doctype['type'])) {
                //type was not set by any reason
                //-> set default
                $this->_doctype['type'] = 'xhtml';
            }

            if (!isset($this->_doctype['version'])) {
                //version was not set by any reason
                //-> set default
                if ($this->_doctype['type'] == 'xhtml') {
                    $this->_doctype['version'] = '1.0';
                } else {
                    $this->_doctype['version'] = '4.01';
                }
            }

            if (!isset($this->_doctype['variant'])) {
                //yariant was not set by any reason
                //-> set default
                $this->_doctype['variant'] = 'strict';
            }

            //set the Mime encoding related to the DocType
            if ($this->_doctype['type'] === 'html' ||
                (isset($_SERVER['HTTP_ACCEPT']) &&
                 (strpos($_SERVER['HTTP_ACCEPT'], 'application/xhtml+xml')
                  === false))) {
                $mime = 'text/html';

                if ($this->_doctype['type'] === 'xhtml') {
                    //in XHTML, if the proper Mime type is not supported
                    $this->_doctype['variant'] = 'transitional';
                    $this->_doctype['version'] = '1.0';
                }
            } else {
                //xhtml
                if ($this->_doctype['version'] === '1.0' &&
                    $this->_doctype['variant'] !== 'strict') {
                    $mime = 'text/html';
                } else {
                    $mime = 'application/xhtml+xml';
                }
            }

            $this->setMime($mime);
        } else {
            $root = $this->getRoot();
            $root->setDoctype($type);
        }

        return $this;
    }

    // }}} setDoctype
    // {{{ getDoctype

    /**
     * Returns the !DOCTYPE declaration.
     *
     * @param boolean $asString (Optional) Whether to return attributes as
     *                          string
     *
     * @return string|array String or Array containing a document type
     * @access public
     * @see    HTML_Page2::_getDoctype()
     *
     * @assert() === array('type'=>'xhtml','version'=>'1.0','variant'=>'strict')
     */
    public function getDoctype($asString = false)
    {
        if ($this->isRoot()) {
            $dt = $this->_doctype['type'];    //doctype
            $ve = $this->_doctype['version']; //version
            $va = $this->_doctype['variant']; //variant

            $allDocTypes = \HTML\Common3\Globals::getAllDocTypes();

            if (isset($allDocTypes[$dt][$ve][$va][0])) {
                //no RootElement defined or is the RootElement itself
                $string = $allDocTypes[$dt][$ve][$va][0];

                if ($asString) {
                    return $string;
                } else {
                    return $this->parseDoctypeString($string);
                }
            } else {
                //if Doctype not set
                if ($asString) {
                    return '';
                } else {
                    return array();
                }
            }
        } else {
            $root = $this->getRoot();
            return $root->getDoctype($asString);
        }
    }

    // }}} getDoctype
    // {{{ setMime

    /**
     * Sets the document MIME encoding that is sent to the browser.
     *
     * <p>This usually will be text/html because most browsers cannot yet
     * accept the proper mime settings for XHTML: application/xhtml+xml
     * and to a lesser extent application/xml and text/xml. See the W3C note
     * ({@link http://www.w3.org/TR/xhtml-media-types/
     * http://www.w3.org/TR/xhtml-media-types/}) for more details.</p>
     *
     * <p>Here is a possible way of automatically including the proper mime
     * type for XHTML 1.0 if the requesting browser supports it:</p>
     *
     * <code>
     * <?php
     * // Initialize the Page object:
     * require 'HTML/Common3/Root/Html.php';
     * $page = new \HTML\Common3\Root\Html();
     *
     * // Check if browse can take the proper mime type
     * if ( strpos($_SERVER['HTTP_ACCEPT'], 'application/xhtml+xml') ) {
     * $page->setDoctype('XHTML 1.0 Strict');
     * $page->setMimeEncoding('application/xhtml+xml');
     * } else {
     * // HTML that qualifies for XHTML 1.0 Strict automatically
     * // also complies with XHTML 1.0 Transitional, so if the
     * // requesting browser doesn't take the necessary mime type
     * // for XHTML 1.0 Strict, let's give it what it can take.
     * $page->setDoctype('XHTML 1.0 Transitional');
     * }
     *
     * // finish building your page here..
     *
     * $page->display();
     * ?>
     * </code>
     *
     * @param string $mime new mime type for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    HTML_Page2::setMimeEncoding()
     */
    public function setMime($mime = 'text/html')
    {
        if ($this->isRoot()) {
            $mime = strtolower($this->clean((string) $mime));
            $this->setOption('mime', $mime);
        } else {
            $root = $this->getRoot();
            $root->setMime($mime);
        }

        return $this;
    }

    // }}} setMime
    // {{{ getMime

    /**
     * returns the document MIME encoding that is sent to the browser.
     *
     * @return string
     * @access public
     * @see    getMimeEncoding()
     *
     * @assert() === 'text/html'
     */
    public function getMime()
    {
        if ($this->isRoot()) {
            return $this->getOption('mime');
        } else {
            $root = $this->getRoot();
            return $root->getMimeEncoding();
        }
    }

    // }}} getMime
    // {{{ getPosElements

    /**
     * return a list of all possible Child elements
     *
     * @access public
     * @return array
     *
     * @assert() === array()
     */
    public function getPosElements()
    {
        $posElements = array();
        $elements    = array();
        $root        = $this->getRoot();
        $docType     = $root->getDoctype(false);
        //$allElements = \HTML\Common3\Globals::getAllElements();
        $dt          = $docType['type'];    //doctype
        $ve          = $docType['version']; //version
        $va          = $docType['variant']; //variant

        //get all possible elements
        if (isset($this->_posElements['#all'])) {
            $p           = $this->_posElements['#all'];
            $posElements = array_merge($posElements, $p);
        }

        if (isset($this->_posElements[$dt]['#all'])) {
            $p           = $this->_posElements[$dt]['#all'];
            $posElements = array_merge($posElements, $p);
        }

        if (isset($this->_posElements[$dt][$ve]['#all'])) {
            $p           = $this->_posElements[$dt][$ve]['#all'];
            $posElements = array_merge($posElements, $p);
        }

        if (isset($this->_posElements[$dt][$ve][$va])) {
            $p           = $this->_posElements[$dt][$ve][$va];
            $posElements = array_merge($posElements, $p);
        }

        //get the list of the forbidden elements
        $forbidElements = $this->getForbiddenElements();

        //delete the forbidden elements from the list of possible elements
        $posElements = array_diff($posElements, $forbidElements);

        //check the other elements
        foreach ($posElements as $posElement) {
            $enabled = \HTML\Common3\Globals::isElementEnabled($posElement,
            $dt, $ve, $va);

            if (!$enabled) {
                //the element is not allowed for the document
                // -> check for an replacement
                $replace = \HTML\Common3\Globals::getReplacement($posElement);

                if (is_string($replace)) {
                    $replaceArray = explode('##', $replace);
                    $replace      = $replaceArray[0];
                }

                if ($replace !== null && is_string($replace) &&
                    in_array($replace, $posElements) &&
                    !in_array($replace, $forbidElements)) {
                    $posElement = $replace;
                    $enabled    = true;
                }
            }

            if ($enabled && !in_array($posElement, $forbidElements) &&
                !in_array($posElement, $elements)) {
                $elements[] = $posElement;
            }
        }

        $elements = array_unique($elements);

        return $elements;
    }

    // }}} getPosElements
    // {{{ getForbidElements

    /**
     * return a list of all elements which are forbidden as children
     *
     * @access public
     * @return array
     *
     * @assert() === array()
     */
    public function getForbidElements()
    {
        $forbidElements = array();

        $root    = $this->getRoot();
        $docType = $root->getDoctype(false);

        $dt = $docType['type'];    //doctype
        $ve = $docType['version']; //version
        $va = $docType['variant']; //variant

        if (isset($this->_forbidElements['#all'])) {
            $f              = $this->_forbidElements['#all'];
            $forbidElements = array_merge($forbidElements, $f);
        }

        if (isset($this->_forbidElements[$dt]['#all'])) {
            $f              = $this->_forbidElements[$dt]['#all'];
            $forbidElements = array_merge($forbidElements, $f);
        }

        if (isset($this->_forbidElements[$dt][$ve]['#all'])) {
            $f              = $this->_forbidElements[$dt][$ve]['#all'];
            $forbidElements = array_merge($forbidElements, $f);
        }

        if (isset($this->_forbidElements[$dt][$ve][$va])) {
            $f              = $this->_forbidElements[$dt][$ve][$va];
            $forbidElements = array_merge($forbidElements, $f);
        }

        $forbidElements = array_unique($forbidElements);

        return $forbidElements;
    }

    // }}} getForbidElements
    // {{{ getForbiddenElements

    /**
     * return a list of all elements, which are forbidden as children for all
     * parent elements in the object tree
     *
     * @access protected
     * @return array
     *
     * @assert() === array()
     */
    protected function getForbiddenElements()
    {
        $forbidElements = array();

        $parents = $this->getParentTree();

        foreach ($parents as $object) {
            $f = $object->getForbidElements();

            if (is_array($f)) {
                $forbidElements = array_merge($forbidElements, $f);
            }
        }

        return $forbidElements;
    }

    // }}} getForbiddenElements
    // {{{ getPosAttributes

    /**
     * return a list of all possible Attributes
     *
     * @access public
     * @return array
     *
     * @assert() === array()
     */
    public function getPosAttributes()
    {
        $posAttribs = array();
        $root       = $this->getRoot();
        $docType    = $root->getDoctype(false);
        $dt         = $docType['type'];   //doctype
        $ve         = $docType['version'];//version
        $va         = $docType['variant'];//variant

        if (isset($this->_posAttributes['#all'])) {
            $p          = $this->_posAttributes['#all'];
            $posAttribs = array_merge($posAttribs, $p);
        }

        if (isset($this->_posAttributes[$dt]['#all'])) {
            $p          = $this->_posAttributes[$dt]['#all'];
            $posAttribs = array_merge($posAttribs, $p);
        }

        if (isset($this->_posAttributes[$dt][$ve]['#all'])) {
            $p          = $this->_posAttributes[$dt][$ve]['#all'];
            $posAttribs = array_merge($posAttribs, $p);
        }

        if (isset($this->_posAttributes[$dt][$ve][$va])) {
            $p          = $this->_posAttributes[$dt][$ve][$va];
            $posAttribs = array_merge($posAttribs, $p);
        }

        return $posAttribs;
    }

    // }}} getPosAttributes
    // {{{ setIDs

    /**
     * sets a list of all stored ID's
     *
     * @param array $elements the new possible Element
     *
     * @access public
     * @return \HTML\Common3
     */
    public function setIDs(array $elements)
    {
        if ($this->isRoot()) {
            $this->_ids = $elements;
        } else {
            $root = $this->getRoot();
            $root->setIDs($elements);
        }

        return $this;
    }

    // }}} setIDs
    // {{{ getIDs

    /**
     * return a list of all stored ID's
     *
     * @access public
     * @return array
     *
     * @assert() === array()
     */
    public function getIDs()
    {
        if ($this->isRoot()) {
            return $this->_ids;
        } else {
            $root = $this->getRoot();
            return $root->getIDs();
        }
    }

    // }}} getIDs
    // {{{ setElementNamespace

    /**
     * Sets the elements namespace
     *
     * @param string $namespace (Optional) W3C namespaces are used by default.
     *
     * @access public
     * @return \HTML\Common3
     */
    public function setElementNamespace($namespace = '')
    {
        $namespace = $this->clean((string) $namespace);

        $this->_elementNamespace = $namespace;

        return $this;
    }

    // }}} setElementNamespace
    // {{{ getElementNamespace

    /**
     * Retrieves the elements namespace
     *
     * @return string
     * @access protected
     *
     * @assert() === ''
     */
    protected function getElementNamespace()
    {
        return $this->_elementNamespace;
    }

    // }}} getElementNamespace
    // {{{ setNamespace

    /**
     * Sets the document namespace
     *
     * <p>By default, W3C namespaces are used. However, if you need to define
     * your own namespace, you can set it here.</p>
     *
     * <p>Usage:<p>
     *
     * <code>
     * // This is how you can set your own namespace:
     * $page->setNamespace('http://www.w3.org/1999/xhtml');
     *
     * // This reverts to default setting and retrieves the appropriate
     * // W3C namespace for the document type:
     * $page->setNamespace();
     * </code>
     *
     * @param string $namespace (Optional) W3C namespaces are used by default.
     * @param string $prefix    (Optional) Prefix for the Namespace,
     *                                     if it is not the default
     *
     * @access public
     * @return string the used prefix
     * @see    HTML_Page2::setNamespace()
     */
    public function setNamespace($namespace = '', $prefix = '')
    {
        $namespace = (string) $namespace;

        if ($this->isRoot()) {
            if ($namespace === '') {
                $namespace = $this->getNamespace(false, $prefix);
            }

            if (($pos = strpos($namespace, '##', 0)) !== false) {
                $split     = explode('##', $namespace);
                $prefix    = $split[1];
                $namespace = $split[0];
            }

            if ((!in_array($namespace, $this->_namespace) ||
                 !array_key_exists($prefix, $this->_namespace)) &&
                $namespace != '') {

                $this->_namespace[$prefix] = $namespace;
            }
        } else {
            $root   = $this->getRoot();
            $prefix = $root->setNamespace($namespace, $prefix);
        }

        //set the prefix as namespace for the element
        $this->setElementNamespace($prefix);

        return $prefix;
    }

    // }}} setNamespace
    // {{{ getNamespace

    /**
     * Retrieves the document namespace
     *
     * @param boolean $useInternalSource (Optional) W3C namespaces are used by
     *                                   Default.
     * @param string  $prefix            (Optional) Prefix for the Namespace,
     *                                   if it is not the default
     *
     * @return string
     * @access protected
     * @see    HTML_Page2::_getNamespace()
     */
    protected function getNamespace($useInternalSource = true, $prefix = '')
    {
        if ($this->isRoot()) {
            $docType = $this->getDoctype(false);
            $dt      = $docType['type'];    //doctype
            $ve      = $docType['version']; //version

            $allNamespaces = \HTML\Common3\Globals::getAllNamespaces();

            if ($useInternalSource && isset($this->_namespace[$prefix]) &&
                $this->_namespace[$prefix] != '') {

                $namespace = $this->_namespace[$prefix];
            } elseif (isset($allNamespaces[$dt][$ve])) {
                $namespace = $allNamespaces[$dt][$ve];

                if ($useInternalSource) {
                    $this->_namespace[$prefix] = $namespace;
                }
            } else {
                $namespace = null;
            }

            return $namespace;
        } else {
            $root = $this->getRoot();
            return $root->getNamespace($useInternalSource, $prefix);
        }
    }

    // }}} getNamespace
    // {{{ setAddToDtd

    /**
     * sets an Indicator, if not existing elements or attributes can be added to
     * the DTD
     *
     * @param boolean $addToDtd Indicator to set
     *
     * @return \HTML\Common3
     * @access public
     */
    public function setAddToDtd($addToDtd = false)
    {
        if ($this->isRoot()) {
            $this->_addToDtd = (boolean) $addToDtd;
        } else {
            $root = $this->getRoot();
            $root->setAddToDtd($addToDtd);
        }

        /*
         @see http://www.alistapart.com/articles/customdtd/

        <!DOCTYPE html PUBLIC
        "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
        [
          <!ATTLIST textarea maxlength CDATA #IMPLIED>
          <!ATTLIST textarea required (true|false) #IMPLIED>
          <!ATTLIST input required (true|false) #IMPLIED>
          <!ATTLIST select required (true|false) #IMPLIED>
        ]>
        */

        return $this;
    }

    // }}} setAddToDtd
    // {{{ getAddToDtd

    /**
     * returns an Indicator, if not existing elements or attributes can be added
     * to the DTD
     *
     * @return boolean
     * @access public
     *
     * @assert() === false
     */
    public function getAddToDtd()
    {
        if ($this->isRoot()) {
            return (boolean) $this->_addToDtd;
        } else {
            $root = $this->getRoot();
            return $root->getAddToDtd();
        }
    }

    // }}} getAddToDtd
    // {{{ setLang

    /**
     * sets the Lang Attribute to the element
     *
     * @param string $lang the lang code for the element
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Page2::setLang()
     */
    public function setLang($lang)
    {
        $posElementAttribs = $this->getPosAttributes();

        if (in_array('lang', $posElementAttribs) ||
            in_array('xml:lang', $posElementAttribs)) {

            //Language Code has a Length of max 3 Chars
            $lang    = substr($this->clean((string) $lang), 0, 3);
            $root    = $this->getRoot();
            $docType = $root->getDoctype(false);
            $type    = $docType['type'];

            if ($type === 'html' && in_array('lang', $posElementAttribs)) {
                $this->setAttribute('lang', $lang);
            } elseif ($type === 'xhtml' &&
                      in_array('xml:lang', $posElementAttribs)) {

                $this->setAttribute('xml:lang', $lang);
            }
        }

        return $this;
    }

    // }}} setLang
    // {{{ getLang

    /**
     * returns the Lang Attribute to the element
     *
     * @return string the lang code for the element
     * @access public
     * @see    HTML_Page2::getLang()
     *
     * @assert() === ''
     */
    public function getLang()
    {
        $posElementAttribs = $this->getPosAttributes();
        $lang              = null;

        if (in_array('lang', $posElementAttribs) ||
            in_array('xml:lang', $posElementAttribs)) {

            $root    = $this->getRoot();
            $docType = $root->getDoctype(false);
            $type    = $docType['type'];

            if ($type === 'html' && in_array('lang', $posElementAttribs)) {
                $lang = $this->getAttribute('lang');
            } elseif ($type === 'xhtml' &&
                      in_array('xml:lang', $posElementAttribs)) {

                $lang = $this->getAttribute('xml:lang');
            }
        }

        return $lang;
    }

    // }}} getLang
    // }}} getter and setter functions *****************************************
    // {{{ Attribute related functions *****************************************
    // {{{ parseAttributes

    /**
     * Parses the HTML attributes given as string
     *
     * @param array|string $attr HTML attribute string or an array
     *
     * @return array       An associative aray of attributes
     * @access protected
     * @see    HTML_Common::_parseAttributes()
     * @see    HTML_Common2::parseAttributes()
     */
    protected function parseAttributes($attr)
    {
        $attributes = array();

        $root = $this->getRoot();
        $name = $this->getElementName();
        $allAttributes = \HTML\Common3\Globals::getAllAttributes();

        if (is_array($attr)) {
            $keys = array_keys($attr);

            foreach ($keys as $key) {
                $value = $attr[$key];

                if (is_int($key)) {
                    $key = $value;
                }

                $key = strtolower($this->clean($key));

                if (array_key_exists($key, $allAttributes)) {
                    if (\HTML\Common3\Globals::isAttributeLowerCased($name,
                    $key)) {
                        $value = strtolower($value);
                    }
                }
                $value = $this->clean($value);

                $attributes[$key] = $value;
            }
        } elseif (is_string($attr)) {
            $attr = $this->clean((string) $attr);
            $regs = array();

            if (preg_match_all(                "/(([A-Za-z_:]|[^\\x00-\\x7F])([A-Za-z0-9_:.-" .
                "]|[^\\x00-\\x7F])*)([ \\n\\t\\r]+)?(=([ \\n" .
                "\\t\\r]+)?(\"[^\"]*\"|'[^']*'|[^ \\n\\t\\r]*" .                "))?/",
                $attr, $regs)) {

                for ($i = 0; $i < count($regs[1]); $i++) {
                    $key   = trim($regs[1][$i]);
                    $check = trim($regs[0][$i]);
                    $value = trim($regs[7][$i]);

                    $value = $this->clean($value);
                    $key   = strtolower($this->clean($key));

                    if ($key == $check) {
                        //empty attribute
                        $value = $key;
                    } else {
                        //none-empty attribute
                        if (!empty($value) &&
                            ($value[0] == '\'' || $value[0] == '"')) {
                            $value = substr($value, 1, -1);
                        }
                    }

                    if (array_key_exists($key, $allAttributes)) {
                        if (\HTML\Common3\Globals::isAttributeLowerCased(
                        $name, $key)) {
                            $value = strtolower($value);
                        }
                    }

                    $attributes[$key] = $value;
                }
            }
        }

        return $attributes;
    }

    // }}} parseAttributes
    // {{{ removeAttributeArray

    /**
     * Removes an attribute from an attribute array
     *
     * @param array  &$attributes Attribute array
     * @param string $name        Name of attribute to remove
     *
     * @return void
     * @access protected
     * @see    HTML_Common2::removeAttributeArray()
     */
    protected function removeAttributeArray(array &$attributes, $name)
    {
        $name = strtolower((string) $name);

        if (isset($attributes[$name])) {
            unset($attributes[$name]);
        }
    }

    // }}} removeAttributeArray
    // {{{ removeAttr

    /**
     * Removes the given attribute from the given array
     *
     * @param string $attr        Attribute name
     * @param array  &$attributes Attribute array
     *
     * @access protected
     * @return void
     * @see    HTML_Common::_removeAttr()
     * @see    removeAttributeArray()
     * @deprecated
     */
    protected function removeAttr($attr, array &$attributes)
    {
        $this->removeAttributeArray($attributes, $attr);
    }

    // }}} removeAttr
    // {{{ getAttributesString

    /**
     * Creates HTML attribute string from array
     *
     * @return string Attribute string
     * @access protected
     * @see    HTML_Common2::getAttributesString()
     */
    protected function getAttributesString()
    {
        $str = '';

        $root = $this->getRoot();
        $name = $this->getElementName();

        $charset = $this->getCharset();

        if ($charset == '') {
            $charset = 'iso-8859-1';

            $this->setCharset($charset);
        }

        $keys          = array_keys($this->_attributes);
        $watched       = $this->_watchedAttributes;
        $posAttributes = $this->getPosAttributes();

        $phpVersion = version_compare(PHP_VERSION, '5.2.3', '>');

        foreach ($keys as $key) {
            $key      = strtolower(trim((string) $key));
            $property = (string) $this->getAttribute($key);
            //var_dump($property);
            if (in_array($key, $posAttributes) &&
                ($property != '' ||
                 in_array($key, $watched))) {

                $attribType = \HTML\Common3\Globals::getTypeName($name, $key);

                if (!$property) {
                    if ($key == 'id') {
                        $property = $this->generateId();
                        $this->_attributes[$key] = $property;
                    }
                    /*
                    if ($attribType === '#IDREF') {
                        throw new \HTML\Common3\InvalidArgumentException(
                            'no ID for this Reference found'
                        );
                    }
                    */
                    if ($key == 'name' && isset($this->_attributes['id'])) {
                        $property = $this->_attributes['id'];
                    }
                }

                if (\HTML\Common3\Globals::isAttributeLowerCased($name, $key)) {
                    $property = strtolower($property);
                }

                $property = $this->decode($property);

                $str .= ' ' . $key . '="';

                if ($attribType == '#SCRIPT') {
                    $str .= $property;
                } else {
                    if ($phpVersion) {
                        $str .= htmlentities($property, ENT_QUOTES, $charset,
                                false);
                    } else {
                        $str .= htmlentities($property, ENT_QUOTES, $charset);
                    }
                }

                $str .= '"';
            }
        }

        return $str;
    }

    // }}} getAttributesString
    // {{{ getAttrString

    /**
     * Creates HTML attribute string from array
     *
     * @return string Attribute string
     * @access protected
     * @see    HTML_Common::_getAttrString()
     * @deprecated
     */
    protected function getAttrString()
    {
        return $this->getAttributesString();
    }

    // }}} getAttrString
    // {{{ existsAttribute

    /**
     * checks if an attribute exists
     *
     * @param string $name Attribute name
     *
     * @access public
     * @return boolean
     */
    public function existsAttribute($name)
    {
        $name = strtolower($this->clean((string) $name));

        return $this->getAttrKey($name, $this->_attributes);
    }

    // }}} existsAttribute
    // {{{ getAttrKey

    /**
     * checks if an key is set in an array
     *
     * @param string $attr       Attribute name
     * @param array  $attributes Array of attributes
     *
     * @access protected
     * @return boolean
     * @see    HTML_Common::_getAttrKey()
     */
    protected function getAttrKey($attr, array $attributes)
    {
        $attr = strtolower($attr);

        if ($attr != '' && isset($attributes[$attr])) {
            return true;
        } else {
            return false;
        }
    }

    // }}} getAttrKey
    // {{{ setAttributes

    /**
     * Sets the attributes
     *
     * @param array|string $attributes Array of attribute 'name' => 'value'
     *                                 pairs or HTML attribute string
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common::setAttributes()
     * @see    HTML_Common2::setAttributes()
     */
    public function setAttributes($attributes)
    {
        $attributes = $this->parseAttributes($attributes);
        $watched    = array();

        foreach ($this->_watchedAttributes as $watchedKey) {
            if (isset($attributes[$watchedKey])) {
                $this->setAttribute($watchedKey, $attributes[$watchedKey]);
                unset($attributes[$watchedKey]);
            } else {
                $this->removeAttribute($watchedKey);
            }

            if (isset($this->_attributes[$watchedKey]) &&
                $this->_attributes[$watchedKey] !== null) {

                $watched[$watchedKey] = $this->_attributes[$watchedKey];
            }
        }

        //merge attributes without parsing again
        $this->mergeAttributes($watched, false);
        $this->mergeAttributes($attributes, false);

        return $this;
    }

    // }}} setAttributes
    // {{{ getAttributes

    /**
     * Returns the attribute array or string
     *
     * @param boolean $asString Whether to return attributes as string
     *
     * @return string|array Either an array or string of attributes
     * @access public
     * @see    HTML_Common::getAttributes()
     * @see    HTML_Common2::getAttributes()
     *
     * @assert() === array()
     */
    public function getAttributes($asString = false)
    {
        if ($asString) {
            return $this->getAttributesString();
        } else {
            return $this->_attributes;
        }
    }

    // }}} getAttributes
    // {{{ mergeAttributes

    /**
     * Merges the existing attributes with the new ones
     *
     * @param array|string $attributes Array of attribute 'name' => 'value'
     *                                 pairs or HTML attribute string
     * @param boolean      $parse      (Optional) TRUE, if the attributes should
     *                                 be parsed
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common2::mergeAttributes()
     */
    public function mergeAttributes($attributes, $parse = true)
    {
        if ($parse) {
            $attributes = $this->parseAttributes($attributes);
        }

        $posAttributes     = $this->getPosAttributes();
        $watchedAttributes = $this->_watchedAttributes;

        $root              = $this->getRoot();
        $allAttributes     = \HTML\Common3\Globals::getAllAttributes();

        $keys = array_keys($attributes);

        foreach ($keys as $key) {
            $value = $attributes[$key];

            if ($value !== null && in_array($key, $posAttributes) &&
                array_key_exists($key, $allAttributes)
               ) {
                $key = strtolower($key);

                if (in_array($key, $watchedAttributes)) {
                    $this->onAttributeChange($key, $value);
                } else {
                    $this->setAttribute($key, $value);
                }
            }
        }

        return $this;
    }

    // }}} mergeAttributes
    // {{{ removeAttribute

    /**
     * Removes an attribute
     *
     * @param string $name Name of attribute to remove
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common::removeAttribute()
     * @see    HTML_Common2::removeAttribute()
     */
    public function removeAttribute($name)
    {
        $name = strtolower($this->clean((string) $name));

        if (isset($this->_attributes[$name])) {
            if (in_array($name, $this->_watchedAttributes)) {
                $this->onAttributeChange($name, null);
            } else {
                $this->removeAttributeArray($this->_attributes, $name);
            }
        }

        return $this;
    }

    // }}} removeAttribute
    // {{{ setId

    /**
     * sets the ID Attribute to the element
     *
     * @param string $id the id for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    HTML_QuickForm2_Node::setId()
     */
    public function setId($id = null)
    {
        if (is_null($id) || empty($id) || (string) $id === '') {
            $root = $this->getRoot();
            $id   = $root->generateId($this->getName());
        }

        $this->setAttribute('id', $id);
        $this->setName($id);

        return $this;
    }

    // }}} setId
    // {{{ getId

    /**
     * returns the ID Attribute of the element
     *
     * @return string the id for the element
     * @access public
     * @see    HTML_QuickForm2_Node::getId()
     *
     * @assert() === null
     */
    public function getId()
    {
        return $this->getAttribute('id');
    }

    // }}} getId
    // {{{ onAttributeChange

    /**
     * Called if trying to change an attribute with name in $watchedAttributes
     *
     * This method is called for each attribute whose name is in the
     * $watchedAttributes array and which is being changed by setAttribute(),
     * setAttributes() or mergeAttributes() or removed via removeAttribute().
     * Note that the operation for the attribute is not carried on after calling
     * this method, it is the responsibility of this method to change or remove
     * (or not) the attribute.
     *
     * @param string $name  Attribute name
     * @param string $value Attribute value, null if attribute is being removed
     *
     * @return void
     * @access protected
     * @see    HTML_Common2::onAttributeChange()
     */
    protected function onAttributeChange($name, $value = null)
    {
        $name = (string) $name;

        if ($name != '') {
            if ($value === null) {
                //unset($this->_attributes[$name]);
            } else {
                $root    = $this->getRoot();
                $docType = $root->getDoctype(false);

                $value = (string) $value;

                if ($docType['type'] == 'xhtml') {
                    $value = str_replace('&', '&amp;', $value);
                }

                $this->_attributes[$name] = $value;
            }
        }
    }

    // }}} onAttributeChange
    // {{{ updateAttributes

    /**
     * Updates the passed attributes without changing the other existing
     * attributes
     *
     * @param string|array $attributes Either a typical HTML attribute string or
     *                          an associative array
     *
     * @access public
     * @return boolean
     * @see    HTML_Common::updateAttributes()
     * @see    updateAttrArray()
     */
    public function updateAttributes($attributes)
    {
        return $this->updateAttrArray($this->_attributes,
                                      $this->parseAttributes($attributes));
    }

    // }}} updateAttributes
    // {{{ updateAttrArray

    /**
     * Updates the attributes in $attr1 with the values in $attr2 without
     * changing the other existing attributes
     *
     * @param array &$attr1 Original attributes array
     * @param array $attr2  New attributes array
     *
     * @return boolean
     * @access protected
     * @see    HTML_Common::_updateAttrArray()
     */
    protected function updateAttrArray(array &$attr1, array $attr2)
    {
        $keys = array_keys($attr2);
        foreach ($keys as $key) {
            $attr1[$key] = $attr2[$key];
        }

        return true;
    }

    // }}} updateAttrArray
    // {{{ generateId

    /**
     * Generates an id for the element
     *
     * Called when an element is created without explicitly given id
     *
     * @param string $elementName Element name
     *
     * @return string The generated element id
     * @access protected
     * @throw  \HTML\Common3\InvalidArgumentException
     * @see    HTML_QuickForm2_Node::generateId()
     */
    protected function generateId($elementName = '')
    {
        $id = (string) $this->getId();
        if ($id !== '') {
            return $id;
        }

        $tokens = (strlen((string) $elementName)?
                   implode('-', explode('[', str_replace(']', '',
                   (string) $elementName))): 'qfauto_01');

        $root      = $this->getRoot();
        $container =& $root->_ids;

        $token     = 0;

        do {
            if (isset($container[$tokens])) {
                $tokens++;
            } else {
                $container[$tokens] =& $this;
                break;
            }
        } while (true);

        return $tokens;
    }

    // }}} generateId
    // {{{ storeId

    /**
     * Stores the explicitly given id to prevent duplicate id generation
     *
     * @param string      $id      the Element's id
     * @param object|null $element the Element object, if it is set to an
     *                             foreign object
     *
     * @return bollean True, if the ID is stored, FALSE otherwise
     * @access protected
     * @throw  \HTML\Common3\InvalidArgumentException
     * @see    HTML_QuickForm2_Node::storeId()
     */
    protected function storeId($id, $element = null)
    {
        if ($id == '' || $id === null) {
            return false;
        }

        $id = (string) $id;
        if ($element === null) {
            $element =& $this;
        }

        if ($this->registerId($id) === true) {
            $root      = $this->getRoot();
            $container =& $root->_ids;

            if (!isset($container[$id])) {
                $container[$id] =& $element;
                return true;
            } elseif (isset($container[$id]) &&
                ($container[$id] === null || $container[$id] === '')) {
                $container[$id] =& $element;
                return true;
            } else {
                return false;
            }
        }

        return false;
    }

    // }}} storeId
    // {{{ registerId

    /**
     * Registers the explicitly given id to prevent duplicate id generation
     *
     * @param string $id Element id
     *
     * @return bollean True, if the ID is registered, FALSE otherwise
     * @access protected
     * @throw  \HTML\Common3\InvalidArgumentException
     */
    protected function registerId($id)
    {
        $id = (string) $id;

        $root      = $this->getRoot();
        $container =& $root->_ids;

        if (!isset($container[$id])) {
            $container[$id] = '';
            return true;
        } else {
            $usedBy = '';

            if (is_string($container[$id]) || is_int($container[$id])) {
                $usedBy = $container[$id];
            } elseif (is_object($container[$id])) {
                $usedBy = $container[$id]->getId();
            }

            $isSelf = false;

            if ($usedBy == $id) {
                if (is_object($container[$id])) {
                    if ($this->getElementName() ==
                        $container[$id]->getElementName()) {
                        $isSelf = true;
                    }
                } else {
                    $isSelf = true;
                }
            }

            if ($isSelf === true) {
                return true;
            } elseif ($usedBy != '') {
                throw new \HTML\Common3\CanNotRegisterIDException(
                    'Registering of ID \'' . $id .
                    '\' was not possible! ID is used already:\'' .
                    $usedBy . '\'.');
            } else {
                return true;
            }
        }

        return false;
    }

    // }}} registerId
    // {{{ getName

    /**
     * returns the Name for this Element
     *
     * @return string
     * @access public
     * @see    HTML_QuickForm2_Node::getName()
     *
     * @assert() === ''
     */
    public function getName()
    {
        return $this->getAttribute('name');
    }

    // }}} getName
    // {{{ setName

    /**
     * sets the Name for this Element
     *
     * @param string $name Element Name
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_QuickForm2_Node::setName()
     */
    public function setName($name)
    {
        $this->setAttribute('name', $this->clean((string) $name));

        return $this;
    }

    // }}} setName
    // }}} Attribute related functions *****************************************
    // {{{ Option related functions ********************************************
    // {{{ setTabOffset

    /**
     * Sets the tab offset
     *
     * @param integer $offset new ident level for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    HTML_Common::setTabOffset()
     * @see    setIndentLevel()
     * @deprecated
     */
    public function setTabOffset($offset)
    {
        return $this->setIndentLevel($offset);
    }

    // }}} setTabOffset
    // {{{ setIndentLevel

    /**
     * Sets the indentation level to an element and all its child elements
     *
     * @param integer $level new ident level for the Element
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common2::setIndentLevel()
     * @see    changeLevel()
     */
    public function setIndentLevel($level)
    {
        $this->changeLevel($level, true);

        return $this;
    }

    // }}} setIndentLevel
    // {{{ getTabOffset

    /**
     * Returns the tabOffset
     *
     * @access public
     * @return integer
     * @see    HTML_Common::getTabOffset()
     * @see    getIndentLevel()
     * @deprecated
     */
    public function getTabOffset()
    {
        return $this->getIndentLevel();
    }

    // }}} getTabOffset
    // {{{ getIndentLevel

    /**
     * Gets the indentation level
     *
     * @return integer
     * @access public
     * @see    HTML_Common2::getIndentLevel()
     *
     * @assert() === 0
     */
    public function getIndentLevel()
    {
        return $this->getOption('level');
    }

    // }}} getIndentLevel
    // {{{ setTab

    /**
     * sets the the Ident for the Element
     *
     * @param string $tab (Optional) the Ident for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    HTML_Common::setTab()
     */
    public function setTab($tab = "    ")
    {
        $this->setOption('indent', (string) $tab);

        return $this;
    }

    // }}} setTab
    // {{{ getTab

    /**
     * Returns a string containing the unit for indenting HTML
     *
     * @return string
     * @access public
     * @see    HTML_Common::_getTab()
     *
     * @assert() === '    '
     */
    public function getTab()
    {
        return $this->getOption('indent');
    }

    // }}} getTab
    // {{{ getTabs

    /**
     * Returns a string containing the offset for the whole HTML code
     *
     * @return string
     * @access protected
     * @see    HTML_Common::_getTabs()
     * @see    getIndent()
     * @deprecated
     *
     * @assert() === ''
     */
    protected function getTabs()
    {
        return $this->getIndent();
    }

    // }}} getTabs
    // {{{ getIndent

    /**
     * Returns the string to indent the element
     *
     * @return string
     * @access protected
     * @see    HTML_Common2::getIndent()
     *
     * @assert() === ''
     */
    protected function getIndent()
    {
        return str_repeat($this->getTab(), $this->getIndentLevel());
    }

    // }}} getIndent
    // {{{ setLineEnd

    /**
     * sets the the Line Break for the Element
     *
     * @param string $break (Optional) the Line Break for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    HTML_Common::setLineEnd()
     */
    public function setLineEnd($break = "\12")
    {
        $this->setOption('linebreak', (string) $break);

        return $this;
    }

    // }}} setLineEnd
    // {{{ getLineEnd

    /**
     * Returns the lineEnd
     *
     * @access public
     * @return string
     * @see    HTML_Common::_getLineEnd()
     *
     * @assert() === "\12"
     */
    public function getLineEnd()
    {
        return $this->getOption('linebreak');
    }

    // }}} getLineEnd
    // {{{ setComment

    /**
     * Sets the comment for the element
     *
     * @param string $comment new comment for the element
     *
     * @return \HTML\Common3
     * @access public
     * @see    HTML_Common::setComment()
     * @see    HTML_Common2::setComment()
     */
    public function setComment($comment)
    {
        $this->setOption('comment', (string) $comment);
        return $this;
    }

    // }}} setComment
    // {{{ getComment

    /**
     * Returns the comment associated with the element
     *
     * @return string
     * @access public
     * @see    HTML_Common::getComment()
     * @see    HTML_Common2::getComment()
     *
     * @assert() === null
     */
    public function getComment()
    {
        return $this->getOption('comment');
    }

    // }}} getComment
    // {{{ setCharset

    /**
     * sets the the Charset for the Element
     *
     * @param string $charset (Optional) the Charset for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    HTML_Page2::setCharset()
     */
    public function setCharset($charset = 'iso-8859-1')
    {
        $this->setOption('charset', (string) $charset);
    }

    // }}} setCharset
    // {{{ charset

    /**
     * Sets the charset to use by htmlspecialchars() function
     *
     * @param string $newCharset (Optional) New charset to use. Omit if just
     *                           getting the current value. Consult the
     *                           htmlspecialchars() docs for a list of supported
     *                           character sets.
     *
     * @return string Current charset
     * @access public
     * @see    HTML_Common::charset()
     *
     * @assert() === 'utf-8'
     * @assert('ISO-8859-1') === 'utf-8'
     * @assert() === 'ISO-8859-1'
     * @deprecated
     */
    public function charset($newCharset = null)
    {
        $charset = $this->getCharset();

        if (!is_null($newCharset)) {
            $this->setCharset($newCharset);
        }

        return $charset;
    }

    // }}} charset
    // {{{ getCharset

    /**
     * returns the the Charset for the Element
     *
     * @return string the Charset for the element
     * @access public
     * @see    HTML_Page2::getCharset()
     *
     * @assert() === 'utf-8'
     */
    public function getCharset()
    {
        return $this->getOption('charset');
    }

    // }}} getCharset
    // {{{ changeLevel

    /**
     * sets a new level to the Element and its Child elements
     *
     * @param int     $level     the level in which should startet the output,
     *                           the internal level is updated
     * @param boolean $recursive if true the function run recursive
     *
     * @return void
     * @access public
     */
    public function changeLevel($level = null, $recursive = true)
    {
        //var_dump($this->_elementName . '::changeLevel');        //var_dump($level);        $level = (int) $level;

        //var_dump($level);
        if ($level < 0) {
            $level = 0;
        }

        //var_dump($level);        //var_dump('$recursive');
        //var_dump($recursive);
        $this->setOption('level', $level);

        $recursive = (boolean) $recursive;

        //var_dump($recursive);
        if ($recursive) {            $newLevel = $level + 1;
            foreach ($this->_elements as $element) {
                if (is_object($element)) {
                    if (is_subclass_of($element, '\HTML\Common3')) {
                        $lang = $element->getLang();
                        if ($lang == '' || $lang == 'std') {
                            $element->setLang($this->getLang());
                        }

                        $element->changeLevel($newLevel, $recursive);
                    }
                }
            }
        }
    }

    // }}} changeLevel
    // {{{ getContentType

    /**
     * returns the Content type
     *
     * @access protected
     * @return string
     */
    protected function getContentType()
    {
        return $this->getMime() . '; charset=' . $this->getCharset();
    }

    // }}} getContentType
    // }}} Option related functions ********************************************
    // {{{ magical functions ***************************************************
    // {{{ __set

    /**
     * Sets the value of the attribute
     *
     * @param string $name  Attribute name
     * @param string $value Attribute value (will be set to $name if omitted)
     *
     * @return void
     * @access public
     * @see    setAttribute()
     */
    public function __set($name, $value)
    {
        $this->setAttribute($name, $value);
    }

    // }}} __set
    // {{{ __get

    /**
     * Returns the value of an attribute
     *
     * @param string $name Attribute name
     *
     * @return string|null Attribute value, null if attribute does not exist
     * @access public
     * @see    getAttribute()
     */
    public function __get($name)
    {
        return $this->getAttribute($name);
    }

    // }}} __get
    // {{{ __isset

    /**
     * checks if an attribute exists
     *
     * @param string $name Attribute name
     *
     * @return boolean
     * @access public
     * @see    existsAttribute()
     */
    public function __isset($name)
    {
        return $this->existsAttribute($name);
    }

    // }}} __isset
    // {{{ __unset

    /**
     * Sets the value of the attribute
     *
     * @param string $name Attribute name
     *
     * @return \HTML\Common3
     * @access public
     * @see    removeAttribute()
     */
    public function __unset($name)
    {
        $this->removeAttribute($name);

        return $this;
    }

    // }}} __unset
    // {{{ __toString

    /**
     * Returns the Element structure as HTML, works recursive
     *
     * @return string
     * @access public
     * @see    toHtml()
     * @see    HTML_Common2::__toString()
     */
    public function __toString()
    {
        return $this->toHtml();
    }

    // }}} __toString
    // {{{ __call

    /**
     * throws an error
     *
     * @param mixed $m called method
     * @param mixed $a method attributes
     *
     * @return void
     * @access public
     * @throws PHP Error
     */
    public function __call($m, $a)
    {
        throw new \HTML\Common3\InvalidArgumentException(
            "Fatal error: Call to undefined method " .
            get_class($this) . "::" . $m . "()"
        );
    }

    // }}} __call
    // }}} magical functions ***************************************************
    // {{{ Alias functions *****************************************************
    // {{{ getEmpty

    /**
     * Returns true, if the Element is empty, false otherwise
     *
     * @return boolean
     * @access public
     * @see    getElementEmpty
     *
     * @assert() === false
     */
    public function getEmpty()
    {
        return $this->getElementEmpty();
    }

    // }}} getEmpty
    // {{{ setMimeEncoding

    /**
     * Sets the document MIME encoding that is sent to the browser.
     *
     * @param string $type new mime type for the element
     *
     * @access public
     * @return \HTML\Common3
     * @see    setMime()
     * @deprecated
     */
    public function setMimeEncoding($mime = 'text/html')
    {
        $this->setMime($mime);

        return $this;
    }

    // }}} setMimeEncoding
    // {{{ getMimeEncoding

    /**
     * returns the document MIME encoding that is sent to the browser.
     *
     * @return string
     * @access public
     * @see    getMime()
     * @deprecated
     *
     * @assert() === 'text/html'
     */
    public function getMimeEncoding()
    {
        return $this->getMime();
    }

    // }}} getMimeEncoding
    // {{{ getType

    /**
     * returns the element type
     *
     * @return string the element type (mostly the same as the element name)
     * @access public
     * @see    HTML_QuickForm2_Node::getType()
     * @see    getElementName()
     *
     * @assert() === ''
     */
    public function getType()
    {
        return $this->getElementName();
    }

    // }}} getType
    // {{{ isEmpty

    /**
     * Returns true, if the Element is empty
     *
     * @return boolean
     * @access public
     *
     * @assert() === false
     */
    public function isEmpty()
    {
        return $this->getEmpty();
    }

    // }}} isEmpty
    // {{{ isEnabled

    /**
     * Returns true, if the Element is enabled
     *
     * @return boolean
     * @access public
     *
     * @assert() === true
     */
    public function isEnabled()
    {
        if ($this->_disabled) {
            return false;
        } else {
            return true;
        }
    }

    // }}} isEnabled
    // {{{ disable

    /**
     * Sets the element to disabled
     *
     * @return \HTML\Common3
     * @access public
     */
    public function disable()
    {
        $this->setDisabled(true);

        return $this;
    }

    // }}} disable
    // {{{ enable

    /**
     * Sets the element to enabled
     *
     * @return \HTML\Common3
     * @access public
     */
    public function enable()
    {
        $this->setDisabled(false);

        return $this;
    }

    // }}} enable
    // }}} Alias functions *****************************************************
    // {{{ Element related functions *******************************************
    // {{{ getChildren

    /**
     * returns an Array of all Child Elements of the Element
     *
     * @return array
     * @access public
     *
     * @assert() === array()
     */
    public function getChildren()
    {
        return $this->_elements;
    }

    // }}} getChildren
    // {{{ count

    /**
     * Returns the number of elements in the container
     *
     * @return integer
     * @access public
     * @see    HTML_QuickForm2_Container::count()
     *
     * @assert() === 0
     */
    public function count()
    {
        return count($this->_elements);
    }

    // }}} count
    // {{{ addElement

    /**
     * add a new Child Element
     *
     * @param string|\HTML\Common3 $type       the HTML Tag for the new Child
     *                                        Element or an \HTML\Common3 Child
     *                                        object
     * @param string|array        $attributes Array of attribute 'name' =>
     *                                        'value' pairs or HTML attribute
     *                                        string
     * @param integer|boolean     $flag       Determines whether to prepend,
     *                                        append or replace the content.
     *                                        Use pre-defined constants.
     *
     * @return null|\HTML\Common3
     * @access public
     * @throw  \HTML\Common3\Exception
     */
    public function addElement($type, $attributes = null, $flag = HTML_APPEND)
    {
        if ($type === null || $type === '' || is_int($type)) {
            return null;
        }
        if (version_compare(PHP_VERSION, '5.9.9', '>')) {
            if (!is_unicode($type) && !is_string($type) && !is_object($type)) {
                return null;
            }
        } else {
            if (!is_string($type) && !is_object($type)) {
                return null;
            }
        }

        $root        = $this->getRoot();
        $allElements = \HTML\Common3\Globals::getAllElements();
        $elementName = $this->getElementName();

        if (!\HTML\Common3\Globals::getElementChildren($elementName)) {
            return null;
        }

        $posElements = $this->getPosElements();

        $element = null;
        $level   = $this->getOption('level') + 1;
        $docType = $root->getDoctype(false);

        $namespace   = '';

        $dt = $docType['type'];    //doctype
        $ve = $docType['version']; //version
        $va = $docType['variant']; //variant

        if (is_object($type)) {
            $elementType = 'object';

            // If this is an object, attempt to generate the appropriate HTML
            // code.
            $element = $type;

            if (is_subclass_of($type, '\HTML\Common3')) {
                $type = $element->getElementName();

                if (!$attributes) {
                    $attributes = $element->getAttributes(true);
                }

                $element->setParent($this);
                $element->setHtml($root);

                $element->setDoctype($root->getDoctype(true));
                $element->setCharset($root->getCharset());
            } elseif (get_class($element) === 'HTML_QuickForm' ||
                      get_class($element) === 'HTML_QuickForm2' ||
                      is_subclass_of($type, '\HTML_QuickForm') ||
                      is_subclass_of($type, '\HTML_QuickForm2')) {

                $type = 'form';
            } elseif (get_class($element) === 'HTML_Table' ||
                      is_subclass_of($type, '\HTML_Table')) {

                $type = 'table';
            } elseif (get_class($element) === 'HTML_Page' ||
                      get_class($element) === 'HTML_Page2' ||
                      is_subclass_of($type, 'HTML_Page') ||
                      is_subclass_of($type, 'HTML_Page2')) {

                $type = 'html';
            } elseif (get_class($element) === 'HTML_Javascript' ||
                      is_subclass_of($type, '\HTML_Javascript')) {

                $type = 'script';
            } elseif (get_class($element) === 'HTML_CSS' ||
                      is_subclass_of($type, '\HTML_CSS')) {

                $type = 'style';
            } else {
                //not supported
                throw new \HTML\Common3\ChildElementNotSupportedException(
                    'Type of Child Element \'' . get_class($element) .
                    '\' is not supported'
                );
            }
        } elseif (is_string($type)) {
            $type = strtolower($this->clean((string) $type));

            if (strpos($type, ':', 0) !== false) {
                $type = explode(':', $type);

                $namespace = $type[0];//prefix for the Namespace

                if ($root->getNamespace(true, $namespace) === null) {
                    throw new \HTML\Common3\NamespaceNotRegisteredException(
                        'Namespace \'' . $namespace .
                        '\' is not registered yet! Use \'setNamespace\' to ' .
                        'register this Namespace before'
                    );
                }

                $type = $type[1];
            }

            $elementType = 'string';
        } else {
            //not supported
            throw new \HTML\Common3\ChildElementNotSupportedException(
                'Type of Child Element \'' . gettype($element) .
                '\' is not supported'
            );
        }

        if ($namespace == '') {
            while (true) {
                //check, if the element is allowed in the selected document type
                $enabled = \HTML\Common3\Globals::isElementEnabled($type,
                $dt, $ve, $va);

                if ($enabled) {
                    break;
                } else {
                    //if not allowed, check, if there is an replacement
                    $replace = \HTML\Common3\Globals::getReplacement($posElement);

                    if ($replace === null || !is_string($replace)) {
                        $type = '';
                        break;
                    } else {
                        $replace = explode('##', $replace);
                        $type    = $replace[0];
                    }
                }
            }

            /*
             * check, if the element (or its replacement) is allowed
             * as child element
             */
            if ($type !== '' && !in_array($type, $posElements)) {
                $forbidElements = $this->getForbiddenElements();
                //not supported yet
                $addToDdt       = false;//$root->getAddingToDtd();

                if ($addToDdt) {
                    if (in_array($type, $forbidElements)) {
                        //the element is not allowed
                        return null;
                    } elseif (is_object($root) &&
                              (get_class($root) === '\HTML\Common3\Root\Html' ||
                               is_subclass_of($root, '\HTML\Common3\Root\Html')))
                              {
                        /*
                        $root->_allElements[$type]['replace']      = null;
                        $root->_allElements[$type]['hasChildren']  = true;
                        $root->_allElements[$type][$dt][$ve][$va]  = true;
                        $this->_posElements[$dt][$ve][$va][] = $type;
                        */
                        //@todo:
                        //add element to DTD
                        return null;
                    } else {
                        return null;
                    }
                } else {
                    //the element is not allowed,
                    //and change of DTD is not alloed
                    return null;
                }
            }
        }
        //var_dump($type);
        if ($elementType === 'string') {

            $element = null;

            $typeVar = strtoupper(substr($type, 0, 1))
                     . strtolower(substr($type, 1));

            $includeFile = 'HTML/Common3/Root/' . $typeVar . '.php';

            require_once $includeFile;

            if ($type == 'var' || $type == 'if') {
                //Html added to class name because the HTML Tag name is an
                //reserved PHP Code word
                $typeVar .= 'Html';
            }

            $ClassNameVar = "\\HTML\\Common3\\Root\\$typeVar";

            if (class_exists($ClassNameVar)) {
                $element      = new $ClassNameVar(null, $this, $root);
            }
        }

        if ($element !== null) {
            //set attributes to added element
            if (is_subclass_of($element, '\HTML\Common3')) {
                $element->setIndentLevel($level);

                if (count($element->_ids) > 0) {
                    $element->_ids = array();
                }

                $element->setElementNamespace($namespace);
            } elseif (is_subclass_of($element, '\HTML_Common2')) {
                $element->setIndentLevel($level);
            } elseif (is_subclass_of($element, '\HTML_Common')) {
                $element->setTabOffset($level);
            }

            $watched = $element->getWatchedAttributes();
            foreach ($watched as $key) {
                if (!isset($attributes[$key])) {
                    $attributes[$key] = '';
                }
            }
            //var_dump($attributes);
            $element->setAttributes($attributes);

            //add element to list
            if ($flag === HTML_PREPEND) {      // 0
                array_unshift($this->_elements, $element);
            } elseif ($flag === HTML_REPLACE) {// false
                $this->_elements    = array();
                $this->value        = '';
                $this->_elements[0] = $element;
            } elseif ($flag === HTML_APPEND) { // true
                $this->_elements[] = $element;
            } else {                           // other number
                $flag = (int) $flag;
                array_splice($this->_elements, $flag, 0, $element);
            }
        }

        return $element;
    }

    // }}} addElement
    // {{{ getElementById

    /**
     * Returns an element if its id is found
     *
     * @param string $id Element id to find
     *
     * @return \HTML\Common3|null
     * @access public
     * @see    HTML_QuickForm2_Container::getElementById()
     */
    public function getElementById($id)
    {
        $root      = $this->getRoot();
        $container =& $root->_ids;

        $id = $this->clean((string) $id);

        foreach ($container as $element) {
            if ($element->getId() === $id) {
                return $element;
            }
        }

        return null;
    }

    // }}} getElementById
    // {{{ getElementsByName

    /**
     * Returns an array of elements which name corresponds to element
     *
     * @param string $name Elements name to find
     *
     * @return array
     * @access public
     * @see    HTML_QuickForm2_Container::getElementByName()
     */
    public function getElementsByName($name)
    {
        $root      = $this->getRoot();
        $container =& $root->_ids;

        $found = array();
        $name  = $this->clean((string) $name);

        foreach ($container as $element) {
            if ($element->getName() === $name) {
                $found[] = $element;
            }
        }

        return $found;
    }

    // }}} getElementsByName
    // }}} Element related functions *******************************************
    // {{{ output functions ****************************************************
    // {{{ toHtml

    /**
     * Returns the HTML representation of the element
     *
     * This magic method allows using the instances of \HTML\Common3 in string
     * contexts
     *
     * @param int     $step     the level in which should startet the output,
     *                          the internal level is updated
     * @param boolean $dump     if TRUE an dump of the class is created
     * @param boolean $comments if TRUE comments were added to the output
     * @param boolean $levels   if TRUE the levels are added,
     *                          if FALSE the levels will be ignored
     *
     * @access public
     * @return string
     * @see    HTML_Common::toHtml()
     * @see    HTML_Page2::toHtml()
     * @see    write()
     */
    public function toHtml($step = 0, $dump = false, $comments = false,
                           $levels = true)
    {
        $elementName = $this->getElementName();
        $innerHTML   = $this->writeInner($dump, $comments, $levels);
        $txt         = $this->write($elementName, $innerHTML, $step, $dump,
                                    $comments, $levels);

        return $txt;
    }

    // }}} toHtml
    // {{{ toFile

    /**
     * Generates the document and outputs it to a file.
     *
     * <p>Uses {@link file_put_content} when available. Includes a workaround
     * for older versions of PHP.</p>
     *
     * <p>Usage example:</p>
     * <code>
     * <?php
     * require "HTML/Common3/Root/Html.php";
     * $page = new \HTML\Common3\Root\Html();
     * $page->setTitle('My Page');
     * $page->addBodyContent('<h1>My Page</h1>');
     * $page->addBodyContent('<p>First Paragraph.</p>');
     * $page->addBodyContent('<p>Second Paragraph.</p>');
     * $page->toFile('myPage.html');
     * ?>
     * </code>
     *
     * @param string $filename the file name where the HTML content should be
     *                         saved to
     *
     * @return string the HTML content
     * @access public
     * @throw  \HTML\Common3\FileNotExistException
     * @see    HTML_Page2::toFile()
     */
    public function toFile($filename)
    {
        $filename = (string) $filename;
        $txt      = $this->toHtml(0, false, false, false);

        if (function_exists('file_put_content')) {
            file_put_content($filename, $txt);
        } else {
            $file = fopen($filename, 'wb');
            if (version_compare(PHP_VERSION, '5.9.9', '>')) {
                $txt = (binary) $txt;
            }
            fwrite($file, $txt);
            fclose($file);
        }

        if (!file_exists($filename)) {
            throw new \HTML\Common3\FileNotExistException('\HTML\Common3::toFile'
                . '() error: Failed to write to ' . $filename);
        }

        return $txt;
    }

    // }}} toFile
    // {{{ setDisplayHeaders

    /**
     * Outputs the HTML content to the browser
     *
     * @return void
     * @access protected
     */
    protected function setDisplayHeaders()
    {
        if (!$this->cache) {
            $date = gmdate("D, d M Y H:i:s") . " GMT";

            header("Expires: " . $date, true);
            header("Last-Modified: " . $date, true);
            header("Cache-Control: no-store, no-cache, must-revalidate, "
                 . "post-check=0, pre-check=0", true);
            header("Pragma: no-cache", true);
        }

        // set character encoding
        header($this->getContentType());
    }

    // }}} setDisplayHeaders
    // {{{ display

    /**
     * Outputs the HTML content to the browser
     *
     * <p>This method outputs to the default display device. Normally that
     * will be the browser.</p>
     *
     * <p>If caching is turned off, which is the default case, this generates
     * the appropriate headers:</p>
     *
     * <code>
     * header("Expires: Tue, 1 Jan 1980 12:00:00 GMT");
     * header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");
     * header("Cache-Control: no-cache");
     * header("Pragma: no-cache");
     * </code>
     *
     * <p>This functionality can be disabled:</p>
     *
     * <code>
     * $page->setCache('true');
     * </code>
     *
     * @return void
     * @access public
     * @see    HTML_Common::display()
     * @see    HTML_Page2::display()
     */
    public function display()
    {
        if (!headers_sent()) {
            $this->setDisplayHeaders();
        }

        // Generate HTML document
        $strHtml = $this->toHtml(0, false, false, false);

        // Output to browser, screen or other default device
        print $strHtml;
    }

    // }}} display
    // {{{ toStringInner

    /**
     * Returns the Element structure as HTML, works recursive
     * Instead of calling the writeInner function, this function wants to have
     * the inner HTML-code as a parameter
     *
     * @param string  $innerHTML the text inside the Element
     * @param int     $step      the level in which should startet the output,
     *                           the internal level is updated
     * @param boolean $dump      if TRUE an dump of the class is created
     * @param boolean $comments  if TRUE comments were added to the output
     * @param boolean $levels    if TRUE the levels are added,
     *                           if FALSE the levels will be ignored
     *
     * @return string
     * @access protected
     * @see    toHtml()
     * @see    write()
     */
    protected function toStringInner($innerHTML, $step = null, $dump = false,
                                     $comments = false, $levels = true)
    {
        $elementName = $this->getElementName();
        $innerHTML   = (string) $innerHTML;
        $txt         = $this->write($elementName, $innerHTML, $step, $dump,
                                    $comments, $levels);

        return $txt;
    }

    // }}} toStringInner
    // {{{ displayInner

    /**
     * Outputs the HTML content to the browser
     *
     * <p>This method outputs to the default display device. Normally that
     * will be the browser.</p>
     *
     * @return void
     * @access public
     */
    public function displayInner()
    {
        if (!headers_sent()) {
            $this->setDisplayHeaders();
        }

        // Generate HTML document
        $strHtml = $this->writeInner(false, false, false);

        // Output to browser, screen or other default device
        print $strHtml;
    }

    // }}} displayInner
    // {{{ write

    /**
     * Returns the Element structure as HTML, works recursive
     * Instead of calling the writeInner function, this function wants to have
     * the inner HTML-code as a parameter
     *
     * @param string  $elementName the type name of the element
     * @param string  $innerHTML   the text inside the Element
     * @param int     $step        the level in which should startet the output,
     *                             the internal level is updated
     * @param boolean $dump        if TRUE an dump of the class is created
     * @param boolean $comments    if TRUE comments were added to the output
     * @param boolean $levels      if TRUE the levels are added,
     *                             if FALSE the levels will be ignored
     *
     * @return string
     * @access protected
     * @see    toHtml()
     */
    protected function write($elementName, $innerHTML, $step = null,
                             $dump = false, $comments = false, $levels = true)
    {
        if ($this->_disabled) {
            return '';
        }

        $begin_txt     = '';
        $message_txt   = '';
        $txt           = '';
        $innerHTML     = (string) $innerHTML;
        $elementName   = (string) $elementName;
        $root          = $this->getRoot();
        $docType       = $root->getDoctype(false);
        $lineEnd       = $root->getOption('linebreak');
        $allAttributes = \HTML\Common3\Globals::getAllAttributes();

        if ($levels) {
            if ($step !== null) {
                $this->changeLevel((int) $step, false);
            } else {
                $step = $this->getIndentLevel();
            }

            $begin_txt .= $this->getIndent();
        } else {
            $step = 0;
        }

        $childcount      = count($this->_elements);
        $countAttributes = count($this->_attributes);

        if ($countAttributes) {
            $attributesString = $this->getAttributes(true);
        }

        if ($childcount && $comments) {
            $message_txt .= $begin_txt . "<!-- ";

            $message_txt .= "type:" . $elementName;

            if ($this->existsAttribute('id')) {
                $message_txt .= " - id:" . $this->getAttribute('id');
            }

            $message_txt .= " - ";

            $txt .= $message_txt . "begin -->" . $lineEnd;
        }

        $comment = $this->getComment();
        if ($comment) {
            $txt .= $begin_txt . "<!-- " . $comment . " -->" . $lineEnd;
        }

        $txt .= $begin_txt;
        if ($elementName != '') {
            $txt .= "<" . $elementName;
        }

        if ($dump) {
            $txt .= ' step="' . $step . '"';
            $txt .= ' dump="' . (int) $dump . '"';
            $txt .= ' comments="' . (int) $comments . '"';
            $txt .= ' levels="' . (int) $levels . '"';
            $txt .= ' doctype="' . $docType['type'] . '"';
            $txt .= ' version="' . $docType['version'] . '"';
            $txt .= ' variant="' . $docType['variant'] . '"';
            $txt .= ' typeName="' . $elementName . '"';

            if (is_object($this->_parent)) {
                $txt .= ' parentTypeName="' . $this->_parent->getElementName() .
                        '"';
            }

            if (is_object($this->_html)) {
                $txt .= ' HTMLTypeName="' . $this->_html->getElementName() .
                        '"';
            }

            if (is_object($root)) {
                $txt .= ' ROOTTypeName="' . $root->getElementName() . '"';
            }
        }


        if ($countAttributes) {
            $txt .= $attributesString;
        }

        if ($this->_elementEmpty) {
            //empty element
            // -> inner content not possible
            // -> child elements not possible
            if ($elementName != '') {
                if ($docType['type'] == 'xhtml') {
                    $txt .= ' />';
                } else {
                    $txt .= '>';
                }
            }
        } else {
            //none empty element
            // -> inner content possible
            // -> child elements possible
            if ($elementName != '') {
                $txt .= ">";

                if ($childcount) {
                    $txt .= $lineEnd;
                }
            }

            $txt .= $innerHTML;

            if ($elementName != '') {
                if ($childcount) {
                    $txt .= $begin_txt;
                }

                if ($docType['type'] == 'xhtml' ||
                ($docType['type'] == 'html' &&
                isset($allAttributes['html']['end']) &&
                $allAttributes['html']['end'])) {
                    $txt .= "</" . $elementName . ">";
                }
            }
        }

        if ($childcount && $comments) {
            $txt .= $lineEnd . $message_txt . "end -->";
        }

        //if ($levels && $step > 0) {
            $txt .= $lineEnd;
        //}

        return $txt;
    }

    // }}} write
    // {{{ writeInner

    /**
     * Returns the inner Element structure as HTML, works recursive
     *
     * @param boolean $dump     if TRUE an dump of the class is created
     * @param boolean $comments if TRUE comments were added to the output
     * @param boolean $levels   if TRUE the levels are added,
     *                          if FALSE the levels will be ignored
     *
     * @return string
     * @access public
     */
    public function writeInner($dump = false, $comments = false, $levels = true)
    {
        if ($this->_elementEmpty) {
            return '';
        }

        $step       = (int)     $this->getIndentLevel() + 1;        $dump       = (boolean) $dump;
        $comments   = (boolean) $comments;
        $levels     = (boolean) $levels;
        $txt        = '';
        $childcount = count($this->_elements);

        if ($childcount) {
            foreach ($this->_elements as $element) {
                if (is_object($element)) {
                    if (is_subclass_of($element, '\HTML\Common3')) {
                        if ($element->isEnabled()) {
                            $txt .= $element->toHtml($step, $dump, $comments,
                                $levels);
                        }
                    } elseif (is_subclass_of($element, '\HTML_Common')) {
                        $txt .= $element->toHtml();
                    } elseif (is_subclass_of($element, '\HTML_Common2')) {
                        try {
                            $txt .= $element->toHtml();
                        } catch (HTML_QuickForm2_Exception $e) {
                            //no output
                        }
                    }
                }
            }
        }

        return $txt;
    }

    // }}} writeInner
    // }}} output functions ****************************************************
    // {{{ other functions *****************************************************
    // {{{ setValue

    /**
     * sets or adds a value to the element
     *
     * @param string          $value an text that should be the value for the
     *                               element
     * @param integer|boolean $flag  Determines whether to prepend, append or
     *                               replace the content. Use pre-defined
     *                               constants.
     *
     * @return \HTML\Common3
     * @access public
     * @throws \HTML\Common3\InvalidArgumentException
     *
     * NOTE: this function has no relation to the Attribute "value"
     */
    public function setValue($value, $flag = HTML_REPLACE)
    {
        $posElements = $this->getPosElements();
        $key         = 'zero';
        $root        = $this->getRoot();

        if (!$this->_elementEmpty && in_array($key, $posElements) &&
            array_key_exists($key, \HTML\Common3\Globals::getAllElements())) {
            $value = (string) $value;

            $zero  = $this->addElement('zero', null, $flag);
            $leave = $zero->parseValue($value);

            if ($leave === false) {
                $zero->addValue($value);
            }
        }

        return $this;
    }

    // }}} setValue
    // {{{ getValue

    /**
     * gets the value to the element
     *
     * NOTE: this function has no relation to the Attribute "value"
     *
     * @return string
     * @access public
     *
     * @assert() === ''
     */
    public function getValue()
    {
        if (!$this->_elementEmpty) {
            $value = $this->writeInner(false, false, false);
            $value = $this->replace($value, 'delbr');
            $value = $this->replace($value, 'all');
            return $value;
        } else {
            return '';
        }
    }

    // }}} getValue
    // {{{ getDoctypeString

    /**
     * Returns the document type string
     *
     * @access public
     * @return string
     * @see    HTML_Page2::getDoctypeString()
     */
    public function getDoctypeString()
    {
        if ($this->isRoot()) {
            $docType = $this->getDoctype(false);

            $dt = $docType['type'];    //doctype
            $ve = $docType['version']; //version
            $va = $docType['variant']; //variant

            $allDocTypes = \HTML\Common3\Globals::getAllDocTypes();

            if (isset($allDocTypes[$dt][$ve][$va])) {
                $strDoctype = $allDocTypes[$dt][$ve][$va];
                $strDoctype = $this->clean($strDoctype);
            } else {
                $strDoctype = '';
            }

            return $strDoctype;
        } else {
            $root = $this->getRoot();
            return $root->getDoctypeString();
        }
    }

    // }}} getDoctypeString
    // {{{ parseDoctypeString

    /**
     * Parses a doctype declaration like "XHTML 1.0 Strict" to an array and sets
     * the MIME-Type according to the Type and the Variant
     *
     * @param string $string The string to be parsed
     *
     * @return array
     * @access protected
     * @see    HTML_Page2::_parseDoctypeString()
     */
    protected function parseDoctypeString($string = 'XHTML 1.0 Strict')
    {
        $array  = array();
        $string = strtolower((string) $string);

        if (strpos($string, 'xhtml basic', 0) !== false) {
            $array['type']    = 'xhtml';
            $array['variant'] = 'basic';

            $split = explode(' ', $string);

            if (isset($split[2])) {
                $array['version'] = (string) $split[2];
            } else {
                $array['version'] = '1.0';
            }
        } elseif (strpos($string, 'xhtml-print', 0) !== false) {
            $array['type']    = 'xhtml';
            $array['variant'] = 'print';
            $array['version'] = '1.0';
        } else {
            $split         = explode(' ', $string);
            $array['type'] = (string) $split[0];

            if ($array['type'] == 'html' || $array['type'] == 'xhtml') {
                if (isset($split[1])) {
                    $array['version'] = (string) $split[1];
                } else {
                    $array['version'] = (($array['type'] === 'html') ?
                        '4.01' :
                        '1.0'
                    );
                }

                if (isset($split[2])) {
                    $array['variant'] = (string) $split[2];
                } else {
                    $array['variant'] = 'strict';
                }
            } else {
                //given Doctype is not supported
                //->set default
                $array['type']    = 'xhtml';
                $array['variant'] = 'strict';
                $array['version'] = '1.0';
            }
        }

        return $array;
    }

    // }}} parseDoctypeString
    // {{{ getParentTree

    /**
     * returns a list of all elements which are in in the parent tree of the
     * current element
     *
     * @access protected
     * @return array
     */
    protected function getParentTree()
    {
        $parents = array();
        $object  =& $this;

        while (is_object($object)) {
            $parents[] =& $object;
            $object    =& $object->_parent;
        }

        return $parents;
    }

    // }}} getParentTree
    // {{{ parseValue

    /**
     * parses an text value into its html components
     *
     * @param string          $value an text that should be the value for the
     *                               element
     * @param integer|boolean $flag  Determines whether to prepend, append or
     *                               replace the content.
     *                               Use pre-defined constants.
     *
     * @access protected
     * @return \HTML\Common3
     */
    protected function parseValue($value, $flag = HTML_APPEND)
    {
        $value = $this->replace($value, 'toXml');
        $value = '<zero>' . $value . '</zero>';
        $value = $this->encode($value);
        $xml = xml_parser_create('');
        xml_parser_set_option($xml, XML_OPTION_SKIP_WHITE,1);
        xml_parser_set_option($xml, XML_OPTION_CASE_FOLDING, 0);
        xml_parser_set_option($xml, XML_OPTION_TARGET_ENCODING, 'ISO-8859-1');

        $value = $this->encode($value);

        $values = array();
        $tags   = array();

        if (version_compare(PHP_VERSION, '5.9.9', '>')) {
            $value = (binary) $value;
        }

        xml_parse_into_struct($xml, $value, $values, $tags);
        $error = xml_get_error_code($xml);

        if ($error) {
            var_dump($value);
            throw new \HTML\Common3\Exception(xml_error_string($error));
        }

        $return        = array();
        $stack         = '';
        $attrs         = array();
        $levelCounters = array(0);

        foreach ($values as $xml_elem) {
            if ($xml_elem['type'] == 'open') {
                if (array_key_exists('attributes', $xml_elem)) {
                    list($level[$xml_elem['level']], $extra) =
                                          array_values($xml_elem['attributes']);
                } else {
                    $level[$xml_elem['level']] = $xml_elem['tag'];
                }
            }
            if ($xml_elem['type'] == 'complete') {
                $start_level = 1;
                $php_stmt = '$return';
                while($start_level < $xml_elem['level']) {
                    $php_stmt .= '[$level['.$start_level.']]';
                    $start_level++;
                }
                $php_stmt .= '[$xml_elem[\'tag\']] = '
                           . '((isset($xml_elem[\'value\'])) ? '
                           . '$xml_elem[\'value\'] : null);';

                eval($php_stmt);
            }
        }

        $keys   = array_keys($return);
        $result = $return[$keys[0]];

        xml_parser_free($xml);

        if (is_array($result)) {
            $this->parseValueArray($this, $result, $flag);
        } elseif ($this->getElementName() == '') {
            $this->_value = $result;
        } else {
            $zero = $this->addElement('zero', null, $flag);
            $zero->setValue($result, false, true);
        }

        return $this;
    }

    // }}} parseValue
    // {{{ parseValueArray

    /**
     * parses an text value which is transformed into an array
     * into its html components
     *
     * @param \HTML\Common3    $parent     the object where the elements should
     *                                    be added
     * @param array           $valueArray an content array to be transformed
     * @param integer|boolean $flag       Determines whether to prepend,
     *                                    append or replace the content.
     *                                    Use pre-defined constants.
     *
     * @access protected
     * @return \HTML\Common3
     */
    protected function parseValueArray(\HTML\Common3 $parent, array $valueArray,
                                       $flag = HTML_APPEND)
    {
        if (!isset($valueArray['children'])) {
            return $this;
        }

        foreach ($valueArray['children'] as $value) {
            $element = $parent->addElement($value['name'], $value['attributes'],
                       $flag);

            if ($element !== null && is_object($element)) {
                $parent->parseValueArray($element, $value, $flag);

                if ($value['value'] != '') {
                    $zero = $element->addElement('zero', null, $flag);
                    $zero->setValue($value['value'], false, true);
                }
            }
        }

        return $this;
    }

    // }}} parseValueArray
    // {{{ replace

    /**
     * replaces special chars with their HTML-code
     *
     * @param string $str  the string which includes the special chars
     * @param string $what (optional) the code what to replace
     *
     * @return string the string with replaced content
     * @access public
     */
    public function replace($str, $what = '')
    {
        $str  = (string) $str;
        $what = (string) $what;

        if (file_exists('HTML/Entities.php')) {
            require_once 'HTML/Entities.php';
            $entity = true;

            $root    = $this->getRoot();
            $docType = $root->getDoctype(false);
            $dt      = $docType['type'];    //type
            $ve      = $docType['version']; //version

            if ($dt == 'html') {
                $coding = HTML_Entities::HTML40;
            } elseif ($ve == '1.0') {
                $coding = HTML_Entities::XHTML10;
            } else {
                $coding = HTML_Entities::XML;
            }
        } else {
            $entity = false;
        }

        if ($what == 'delbr') {
            $str = $this->clean($str);
            $str = str_replace('<br>', '', $str);
            $str = str_replace('<br/>', '', $str);
            $str = str_replace('<br />', '', $str);
        } elseif ($what == 'changebr') {
            $r = (strtolower(substr(PHP_OS, 0, 3)) == 'win' ?
                 '&#10;&#13;' :
                 '&#10;');

            $str = str_replace('<br>', $r, $str);
            $str = str_replace('<br/>', $r, $str);
            $str = str_replace('<br />', $r, $str);
        } elseif ($what == '&amp;') {
            //re-encode &amp; to &
            $str = str_replace('&amp;', '&', $str);
        } elseif ($what == 'utf8') {
            $str = $this->decode($str);
        } elseif ($what == 'all') {
            $str = $this->replace($str, 'utf8');

            if ($entity) {
                $str = HTML_Entities::encode($str, HTML_Entities::NAMES,
                       $coding);
            } else {
                $str = $this->replace($str, 'um1');
                $str = $this->replace($str, 'um2');
                $str = $this->replace($str, 'um3');
            }

            $str = $this->replace($str, 'br');
        } elseif ($what == 'um') {
            //encode special chars only
            $str = $this->replace($str, 'utf8');

            if ($entity) {
                $str = HTML_Entities::encode($str, HTML_Entities::NAMES,
                       $coding | HTML_Entities::IGNORE_SPECIAL_CHARS);
            } else {
                $str = $this->replace($str, 'um1');
                $str = str_replace('&lt;', '<', $str);
                $str = str_replace('&gt;', '>', $str);
                $str = str_replace('&quot;', '"', $str);
                $str = $this->replace($str, 'um2');
                $str = $this->replace($str, 'um3');
            }

            $str = $this->replace($str, 'br');
        } elseif ($what == 'um1') {
            $str = htmlentities($str);
            $str = $this->replace($str, '&amp;');
        } elseif ($what == 'um2') {
            //rework for double encoded characters and utf-8 text
            $str = str_replace('&amp;nbsp;', '&nbsp;', $str);
            $str = str_replace('&amp;#064;', '&#064;', $str);
            $str = str_replace('&amp;amp;', '&amp;', $str);
            $str = str_replace('&amp;frac14;', '&frac14;', $str);
            $str = str_replace('&amp;Atilde;', '&Atilde;', $str);
            $str = str_replace('&amp;uuml;', '&uuml;', $str);
            $str = str_replace('&amp;auml;', '&auml;', $str);
            $str = str_replace('&amp;ouml;', '&ouml;', $str);
            $str = str_replace('&Atilde;&curren;', '&auml;', $str);
            $str = str_replace('&Atilde;&frac14;', '&uuml;', $str);
            $str = str_replace('ü', '&uuml;', $str);
            $str = str_replace('ö', '&ouml;', $str);
            $str = str_replace('&Atilde;&para;', '&ouml;', $str);
            $str = str_replace('&Atilde;&shy;', 'i', $str);
            $str = str_replace('&Atilde;€', 'A', $str);
        } elseif ($what == 'um3') {
            $docType = $this->getDoctype(false);

            if ($docType['type'] === 'xhtml') {
                //ignore if only HTML
                //HTML Chars
                $str = str_replace('&lt;', '&#60;', $str);
                $str = str_replace('&gt;', '&#62;', $str);
                $str = str_replace('&amp;', '&#38;', $str);
                $str = str_replace('&apos;', '&#39;', $str);
                $str = str_replace('&quot;', '&#34;', $str);
                //Trade
                $str = str_replace('@', '&#64;', $str);
                $str = str_replace('&copy;', '&#169;', $str);
                $str = str_replace('&reg;', '&#174;', $str);
                $str = str_replace('&trade;', '&#8482;', $str);
                //
                $str = str_replace('`', '&#96;', $str);
                $str = str_replace('´', '&#180;', $str);
                $str = str_replace('&acute;', '&#180;', $str);
                $str = str_replace('~', '&#126;', $str);
                $str = str_replace('&tilde;', '&#732;', $str);
                $str = str_replace('^', '&#94;', $str);
                $str = str_replace('&circ;', '&#710;', $str);
                $str = str_replace('&uml;', '&#168;', $str);
                $str = str_replace('&cedil;', '&#184;', $str);
                //german special chars
                $str = str_replace('&auml;', '&#228;', $str);
                $str = str_replace('&ouml;', '&#246;', $str);
                $str = str_replace('&uuml;', '&#252;', $str);
                $str = str_replace('&Auml;', '&#196;', $str);
                $str = str_replace('&Ouml;', '&#214;', $str);
                $str = str_replace('&Uuml;', '&#220;', $str);

                $str = str_replace('&Agrave;', '&#192;', $str);
                $str = str_replace('&Aacute;', '&#193;', $str);
                $str = str_replace('&Acirc;', '&#194;', $str);
                $str = str_replace('&Atilde;', '&#195;', $str);
                $str = str_replace('&Aring;', '&#197;', $str);
                $str = str_replace('&Ccedil;', '&#199;', $str);
                $str = str_replace('&Egrave;', '&#200;', $str);
                $str = str_replace('&Eacute;', '&#201;', $str);
                $str = str_replace('&Ecirc;', '&#202;', $str);
                $str = str_replace('&Euml;', '&#203;', $str);
                $str = str_replace('&Igrave;', '&#204;', $str);
                $str = str_replace('&Iacute;', '&#205;', $str);
                $str = str_replace('&Icirc;', '&#206;', $str);
                $str = str_replace('&Iuml;', '&#207;', $str);
                $str = str_replace('&Ntilde;', '&#209;', $str);
                $str = str_replace('&Ograve;', '&#210;', $str);
                $str = str_replace('&Oacute;', '&#211;', $str);
                $str = str_replace('&Ocirc;', '&#212;', $str);
                $str = str_replace('&Otilde;', '&#213;', $str);
                $str = str_replace('&Oslash;', '&#216;', $str);
                $str = str_replace('&Scaron;', '&#352;', $str);
                $str = str_replace('&Ugrave;', '&#217;', $str);
                $str = str_replace('&Uacute;', '&#218;', $str);
                $str = str_replace('&Ucirc;', '&#219;', $str);
                $str = str_replace('&Yacute;', '&#221;', $str);
                $str = str_replace('&Yuml;', '&#376;', $str);

                $str = str_replace('&agrave;', '&#224;', $str);
                $str = str_replace('&aacute;', '&#225;', $str);
                $str = str_replace('&acirc;', '&#226;', $str);
                $str = str_replace('&atilde;', '&#227;', $str);
                $str = str_replace('&aring;', '&#229;', $str);
                $str = str_replace('&ccedil;', '&#231;', $str);
                $str = str_replace('&egrave;', '&#232;', $str);
                $str = str_replace('&eacute;', '&#233;', $str);
                $str = str_replace('&ecirc;', '&#234;', $str);
                $str = str_replace('&euml;', '&#235;', $str);
                $str = str_replace('&igrave;', '&#236;', $str);
                $str = str_replace('&iacute;', '&#237;', $str);
                $str = str_replace('&icirc;', '&#238;', $str);
                $str = str_replace('&iuml;', '&#239;', $str);
                $str = str_replace('&ntilde;', '&#241;', $str);
                $str = str_replace('&ograve;', '&#242;', $str);
                $str = str_replace('&oacute;', '&#243;', $str);
                $str = str_replace('&ocirc;', '&#244;', $str);
                $str = str_replace('&otilde;', '&#245;', $str);
                $str = str_replace('&oslash;', '&#248;', $str);
                $str = str_replace('&scaron;', '&#353;', $str);
                $str = str_replace('&ugrave;', '&#249;', $str);
                $str = str_replace('&uacute;', '&#250;', $str);
                $str = str_replace('&ucirc;', '&#251;', $str);
                $str = str_replace('&yacute;', '&#253;', $str);
                $str = str_replace('&yuml;', '&#255;', $str);

                $str = str_replace('&AElig;', '&#198;', $str);
                $str = str_replace('&aelig;', '&#230;', $str);
                $str = str_replace('&szlig;', '&#223;', $str);
                $str = str_replace('&OElig;', '&#338;', $str);
                $str = str_replace('&oelig;', '&#339;', $str);

                $str = str_replace('&iexcl;', '&#161;', $str);
                $str = str_replace('&iquest;', '&#191;', $str);
                $str = str_replace('&middot;', '&#183;', $str);
            }
        } elseif ($what == 'br') {
            $str = nl2br($str);
        } elseif ($what == 'toXml') {
            //encode to XML format
            $str = $this->replace($str, 'delbr');
            $str = str_replace('&nbsp;', '&amp;nbsp;', $str);
            $str = $this->encode($str);
            //$str = str_replace('&nbsp;', '', $str);
            //'<!--[' . $this->getCondition() . ']>'
            //'<![endif]-->'
            if (strpos($str, '<!--[', 0) !== false) {
                $start       = strpos($str, '<!--[', 0);
                $startIntern = $start + 5;
                $endIntern   = strpos($str, ']>', 0) - 1;
                $end         = $endIntern + 2;
                $condition   = substr($str, $startIntern,
                               $endIntern - $startIntern + 1);
                $replace     = substr($str, $start, $end - $start + 1);

                $str = str_replace($replace, '<if condition="' . $condition .
                       '">', $str);
                $str = str_replace('<![endif]-->', '</if>', $str);
            }
        }

        return $str;
    }

    // }}} replace
    // {{{ getRoot

    /**
     * returns an the Root Element of the object tree
     *
     * @return \HTML\Common3
     * @access public
     */
    public function getRoot()
    {
        if ($this->_isRootElement) {
            $root =& $this;
        } elseif ($this->_html === null && $this->_parent === null) {
            $root =& $this;
        } elseif ($this->_html !== null && is_object($this->_html)) {
            $root =& $this->_html;
            if (method_exists($this->_html, 'getRoot')) {
                $root = $this->_html->getRoot();
            }
        } elseif ($this->_parent !== null && is_object($this->_parent)) {
            $root =& $this->_parent;
            if (method_exists($this->_parent, 'getRoot')) {
                $root = $this->_parent->getRoot();
            }
        } else {
            $root =& $this;
        }

        return $root;
    }

    // }}} getRoot
    // {{{ isRoot

    /**
     * returns an the Indicator if the Element is the Root Element of the object
     * tree
     *
     * @return boolean
     * @access public
     */
    public function isRoot()
    {
        if ($this->_isRootElement) {
            $root = true;
        } elseif ($this->_html === null && $this->_parent === null) {
            $root = true;
        } elseif ($this->_html !== null && is_object($this->_html)) {
            $root = false;
        } elseif ($this->_parent !== null && is_object($this->_parent)) {
            $root = false;
        } else {
            $root = true;
        }

        return $root;
    }

    // }}} isRoot
    // {{{ addDtdAttribute

    /**
     * add an forbidden Element to the dtd to make it possible
     *
     * @param string $elementName the name of the element which should add the
     *                            new attribute for
     * @param string $attribute   the name of the attribute which should be
     *                            added
     * @param string $type        (Optional) the type for the new attribute
     * @param string $need        (Optional) the need level for the new
     *                            attribute
     *
     * @return \HTML\Common3
     * @access public
     */
    public function addDtdAttribute($elementName, $attribute, $type = 'CDATA',
        $need = '#IMPLIED')
    {
        $allNeeds = array(
            '#IMPLIED',
            '#REQUIRED'
        );

        $elementName = strtolower((string) $elementName);
        $attribute   = strtolower((string) $attribute);
        $type        = strtolower((string) $type);
        $need        = strtolower((string) $need);

        if ($elementName == '') {
            $elementName = $this->getElementName();
        }

        if ($elementName !== '' && $attribute !== '' && !$this->isRoot()) {
            if ($type === '') {
                $type = 'CDATA';
            }

            if (!in_array($type, $allNeeds)) {
                $type = '#IMPLIED';
            }

            if ($need === '#REQUIRED') {
                $this->_watchedAttributes[] = $type;
            }

            $root    = $this->getRoot();
            $docType = $root->getDoctype(false);

            $dt = $docType['type'];    //doctype
            $ve = $docType['version']; //version
            $va = $docType['variant']; //variant

            //\HTML\Common3\Globals::getAllAttributes()[$type]['type']    = '#CNAME';
            //\HTML\Common3\Globals::getAllAttributes()[$type]['sc']      = true;
            //\HTML\Common3\Globals::getAllAttributes()[$type]['replace'] = null;
            //\HTML\Common3\Globals::getAllAttributes()[$type]['space']   = false;
            $this->_posAttributes[$dt][$ve][$va][]  = $type;

            $root->addDtdAttribute($elementName, $attribute, $type, $need);
        }

        return $this;
    }

    // }}} addDtdAttribute
    // {{{ collapseInternalSpaces

    /**
     * Strips excess spaces and tabulators in string.
     *
     * @param string $subject string to format
     *
     * @return string
     * @access protected
     */
    protected function collapseInternalSpaces($subject)
    {
        //delete tabulators
        $string = preg_replace('/\t+/', ' ', (string) $subject);
        //delete spaces
        $string = preg_replace('/\s+/', ' ', (string) $subject);
        return $string;
    }

    // }}} collapseInternalSpaces
    // {{{ clean

    /**
     * cleanes a string from spaces and html-tags
     *
     * @param string $str a string to be cleaned
     *
     * @return string the cleaned string
     * @access protected
     */
    protected function clean($str)
    {
        //do not change boolean values
        if (is_bool($str)) {
            return $str;
        }

        if ($str === "\n" || $str === "\t" || $str === "\r" || $str === "\r\n") {
            return $str;
        }

        if ($str === "\12" || $str === "\15" || $str === "\12\15") {
            return $str;
        }

        //delete spaces, if more than two
        $str = $this->collapseInternalSpaces($str);

        //delete text format codes
        $str = str_replace("\n", '', $str);
        $str = str_replace("\r", '', $str);
        $str = str_replace("\f", '', $str);

        //delete HTML-Code
        $str = strip_tags($str);
        $str = trim($str);

        return $str;
    }

    // }}} clean
    // {{{ setAddingToDtd

    /**
     * sets an Indicator, if not existing elements or attributes can be added to
     * the DTD
     *
     * @param boolean $addToDtd Indicator to set
     *
     * @return \HTML\Common3
     * @access public
     */
    public function setAddingToDtd($addToDtd = false)
    {
        return $this->setAddToDtd($addToDtd);
    }

    // }}} setAddingToDtd
    // {{{ getAddingToDtd

    /**
     * returns an Indicator, if not existing elements or attributes can be added
     * to the DTD
     *
     * @return boolean
     * @access public
     *
     * @assert() === false
     */
    public function getAddingToDtd()
    {
        return $this->getAddToDtd();
    }

    // }}} getAddingToDtd
    // {{{ decode

    /**
     * decodes an string from utf-8 to iso
     *
     * @param string $string the string to decode
     *
     * @return string the decoded string
     * @access protected
     */
    protected function decode($string)
    {
        if (function_exists('mb_detect_encoding') &&
            mb_detect_encoding($string.' ','UTF-8,ISO-8859-1') == 'UTF-8') {
            $string = utf8_decode($string);
        }

        return $string;
    }

    // }}} decode
    // {{{ encode

    /**
     * decodes an string from utf-8 to iso
     *
     * @param string $string the string to encode
     *
     * @return string the decoded string
     * @access protected
     */
    protected function encode($string)
    {
        if (function_exists('mb_detect_encoding') &&
            mb_detect_encoding($string . ' ',
                               'UTF-8,ISO-8859-1') == 'ISO-8859-1') {
            $string = utf8_encode($string);
        }

        return $string;
    }

    // }}} encode
    // }}} other functions *****************************************************
}

// }}} \HTML\Common3

/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * c-hanging-comment-ender-p: nil
 * End:
 */